\index{类型!恒等|(defstyle}%
\indexsee{恒等!类型}{类型, 恒等}%
\indexsee{类型!等同}{类型, 恒等}%
\indexsee{等同!类型}{类型, 恒等}%
先前的构造可以视为标准集合论构造的概括, 而处理恒等的方式是类型论特有的.
通过命题即类型的概念, 同一类型的两个元素 $a,b:A$ 等相等的命题\emph{命题}, 必须对应一个\emph{类型}.
因为这个命题依赖于 $a$ 和 $b$, 所以这个\define{等同类型}或者说是\define{恒等类型}必须是一个类型族, 并依赖两个 $A$ 的复制.

这个类型族写作 $\idtypevar{A}:A\to A\to\type$ (不要和恒等函数 $\idfunc[A]$ 混淆), 所以类型 $\idtype[A]ab$ 是一个命题, 表示了 $a$ 和 $b$ 是等同的.
一旦熟悉了命题即类型, 就可以方便地使用标准的等于号;
因此符号``$\id{a}{b}$''也即是\emph{类型} $\idtype[A]ab$, 代表 $a$ 等于 $b$.
为了清楚起见, 显式地指定类型 $A$, 写作 ``$\id[A]{a}{b}$''.
如果有一个 $\id[A]{a}{b}$ 的元素, 可以说 $a$ 和 $b$ \define{相等}, 或者是\define{命题相等}, 后者强调了与\cref{sec:types-vs-sets}中介绍的的定义等同的区别.
\indexdef{等同!命题的}%
\indexdef{命题的!等同}%

和\cref{sec:pat}中, 命题即类型引入的``或''与``存在''包含更多信息, 而不仅只是事实命题为真一样, $\id{a}{b}$ 也能包含更多的信息.
的确, 对应同伦论的基础, $\id{a}{b}$ 的见证可以被视为 $a$ 与 $b$ 在空间 $A$的\emph{路径}\indexdef{路径}或者\emph{等效性}.
正如空间的两点不止一条路径, 两个对象的等同也不止有一个见证.
换句话说, 可以把类型 $\id{a}{b}$ 当作 $a$ 与 $b$ 的\emph{等同}的\indexdef{等同}, 而等同 $a$ 与 $b$ 的方式可能有很多种.
在 \cref{cha:basics} 会回到这个解释;
现在的焦点是恒等类型的基础规则.
就像本章中被考虑的其他类型, 会引入形成规则, 构造规则, 消除规则, 和计算规则, 形式上它们的行为完全相同.

形成规则说明, 给定一个类型 $A:\UU$ 和两个元素 $a,b:A$, 可以在同级宇宙构造类型 $(\id[A]{a}{b}):\UU$.
构造 $\id{a}{b}$ 的元素的基本方法是给出相同的两个元素 $a$ 和 $b$.
因此, 它的构造规则是一个依赖函数
\[
    \refl{} : \prd{a:A} (\id[A]{a}{a})
\]
而被称为\define{自反},
\indexdef{自反!等同的}%
即 $A$ 的元素等于它自己 (以一种特殊的方式).
注意 $\refl{a}$ 被视为点 $a$ 上的常量路径\indexdef{路径!常量}\indexsee{环圈!常量}{路径, 常量}.

特别地, 这意味若 $a$ 和 $b$ 是\emph{判断}等同的, $a\jdeq b$, 那有一个元素 $\refl{a} : \id[A]{a}{b}$.
它是良类型的, 因为 $a\jdeq b$ 意味类型 $\id[A]{a}{b}$ 判断等同于 $\id[A]{a}{a}$, 即 $\refl{a}$.

恒等类型的归纳原理 (即消除规则) 类型论的其中一个微妙之处, 也是同论理解的关键.
首先考虑它的一个重要结论, 即``等于替换等于'' 的原理, 表示如下: \index{恒等的不可辨性}%
\index{等于代替等于}%
\begin{description}
    \item[恒等的不可辨性:]
    对于所有族
    \[
        C : A \to \UU
    \]
    有一个函数函数
    \[
        f : \prd{x,y:A}{p:\id[A] x y} C(x) \to C(y)
    \]
    如此
    \[
        f(x,x,\refl{x}) \defeq \idfunc[C(x)].
    \]
\end{description}
这说明了对于所有类型族 $C$, 分别引用 $C$ 到类型为  $A$ 的两个\emph{相等}的元素, 返回的结果和其类型都是相等的.
表示等同函数与自反性关联(可以看见通常函数 $f(x,y,p): C(x) \to C(y)$ 是一个等效的类型).

恒等的不可辨性可以当作恒等类型的递归原理, 类似于布尔和自然数一样.
就像 $\rec{\nat}$ 给出了可以到达其它任何类型 $C$ 的特殊映射 $\nat\to C$, 恒等的不可辨性给出了从 $\id[A] x y$ 到某些自反的特殊映射, 到达域是在 $A$ 上的二元关系, 对于一元断言 $C(x)$ 来说, 就是 $C(x) \to C(y)$.
也可以把普通的递归原理作为公式, 来表示 $C(x,y)$ 更加通用的自反关系.
不过, 为了充分表征恒等类型, 必须一般化递归原理到归纳原理, 不仅考虑 $\id[A] x y$ 的映射, 还要考虑它的类似情况.
换句话说, 不仅要允许等于代替等于, 还要顾及证据 $p$ 的等同性的证据.

\subsection{路径归纳}

\index{生成!类型的, 归纳|(}
恒等类型的归纳原理被称为\define{路径归纳}, \index{路径!归纳|(}%
\index{归纳原理!恒等类型的|(}%
同伦论中的解释会在 \cref{cha:basics} 阐述.
可以看出, 恒等类型族是由 $\refl{x}: \id{x}{x}$ 形式的元素生成的.

\begin{description}
    \item[路径归纳:]
    给定族
    \[ C : \prd{x,y:A} (\id[A]{x}{y}) \to \UU \]
    和函数
    \[ c : \prd{x:A} C(x,x,\refl{x}),\]
    则有函数
    \[ f : \prd{x,y:A}{p:\id[A]{x}{y}} C(x,y,p) \]
    如此
    \[ f(x,x,\refl{x}) \defeq c(x). \]
\end{description}

注意, 就像乘积, 陪积, 自然数, 等的归纳原理一样, 路径归纳让我们能够定义\emph{指定}的函数, 这些函数表现出适当计算行为.
就像 $f:\nat\to C$ \emph{这个}函数, 它通过 $c_0:C$ 与 $c_s:\nat \to C \to C$ 的递归, 以及 $f(0)\jdeq c_0$ 与 $f(\suc(n))\jdeq c_s(n,f(n))$ 来定义, $f : \dprd{x,y:A}{p:\id[A]{x}{y}} C(x,y,p)$ \emph{这个}函数通过 $c : \prd{x:A} C(x,x,\refl{x})$ 路径归纳的路径函数, 以及 $f(x,x,\refl{x}) \jdeq c(x)$ 定义 .

为了理解这个原理的含义, 首先考虑 $C$ 不依赖依赖于 $p$ 的简单情况.
于是有 $C:A\to A\to \UU$, 可以视为一个断言, 它依赖两个类型为 $A$ 的元素.
令人关注的是, 若 $x,y:A$, 那么命题 $C(x,y)$ 何时成立.
在这种情况下, 路径归纳的猜想表示对于所有 $x:A$, $C(x,x)$ 成立, 即如果给 $C$ 赋值对子 $x, x$, 可以得到一个真命题 --- 所以 $C$ 是一个自反关系.
结论是只要 $\id{x}{y}$ 那么 $C(x,y)$ 成立.
这就是之前提及的, 自反关系的通用递归原理.

归纳的通用之处在于, 归纳规则允许 $C$ 依赖见证 $p:\id{x}{y}$, 即 $x$ 与 $y$ 的恒等性.
在条件中, 把 $x, y$ 替换为 $x,x$, 而 $p$ 也替换为自反: 为了证明对于所有元素 $x,y$ 与路径 $p : \id{x}{y}$ 之间的的性质, 足够考虑元素是 $x,x$ 和路径是 $\refl{x}: \id{x}{x}$ 的所有情况下.
如果把集合看作类型, 那么恒等式是无意义的, 不过在 $x$ 和 $y$ 之间可能存在很多不同恒等式 $p : \id{x}{y}$, 所以在类型族中考虑 $\id[A]{x}{y}$ 是有意义的.
在\cref{cha:basics}可以看到, 它对同伦的理解非常重要.

如果把路径归纳包装为一个单独的函数, 它的形式是这样:
\symlabel{defn:induction-ML-id}%
\begin{narrowmultline*}
    \indid{A} : \dprd{C : \prd{x,y:A} (\id[A]{x}{y}) \to \UU}
    \Parens{\tprd{x:A} C(x,x,\refl{x})} \to
    \narrowbreak
    \dprd{x,y:A}{p:\id[A]{x}{y}} C(x,y,p)
\end{narrowmultline*}
通过定义等同\index{计算规则!恒等类型的} \[ \indid{A}(C,c,x,x,\refl{x}) \defeq c(x). \]
函数 $ \indid{A}$ 即传统上的 $J$.
\indexsee{J@$J$}{恒等类型的归纳原理}%
在 \cref{lem:transport} 会展示恒等的不可辨性是路径归纳的一个实例, 而且会给定新的名称和符号符号.

\mentalpause

给定一个证明 $p : \id{a}{b}$, 路径归纳需要替换\emph{所有} $a$ 和 $b$ 为未知元素 $x$;
因此为了构造族 $C$ 的一个元素, 它的定义域是元素类型为 $A$ 的对子, 只需在对角线定义即可.
不过在一些证明中, 可以通过替换出现的所有 $b$ 为 $a$ (反之亦然) 来使用等式 $p : \id{a}{b}$, 因为有时证明等同中被提及的 $a$ 比普通的未知的~$x$ 更容易.
这推动第二个恒等类型的归纳原理的诞生, 即类型族 $\id[A]{a}{x}$ 被推广为元素 $\refl{a} : \id{a}{a}$.
如下所示, 第二个原则等价于第一个原则;
它只是为了更方便的表述.

\index{路径!基本归纳}%
\index{归纳原理!恒等类型的!基本}%
\begin{description}
    \item[基本路径归纳:]
    规定一个元素 $a:A$, 和给定一个族
    \[ C : \prd{x:A} (\id[A]{a}{x}) \to \UU \]
    和一个元素
    \[ c : C(a,\refl{a}). \]
    然后得到一个函数
    \[ f : \prd{x:A}{p:\id{a}{x}} C(x,p) \]
    如此
    \[ f(a,\refl{a}) \defeq c.\]
\end{description}

在这里, $C(x,p)$ 类型族,  其中 $x$ 是一个 $A$ 的元素而 $p$ 是一个 恒等类型 $\id[A]{a}{x}$ 的元素, 来固定 $A$ 中的 $a$.
该基本路径归纳原理表示, 对于 $x$ 与 $p$, 为了定义一个这个族的元素, 只需考虑 $x$ 是 $a$ 和 $p$ 是 $\refl{a} : \id{a}{a}$ 的情况即可.

封装为函数, 基本路径归纳即:
\symlabel{defn:induction-PM-id}%
\begin{align*}
    \indidb{A} : \dprd{a:A}{C : \prd{x:A} (\id[A]{a}{x}) \to \UU}
    C(a,\refl{a}) \to \dprd{x:A}{p : \id[A]{a}{x}} C(x,p)
\end{align*}
与这个等式 \[ \indidb{A}(a,C,c,a,\refl{a}) \defeq c. \]
%\[ g(x)(x,\refl{x}) \defeq d(x) \]

下面会展示路径归纳与基本路径归纳是等价的.
因此, 有时也会草率把基本路径归纳简化为``路径归纳'', 请读者自己推断到底是哪个原理.

\begin{rmk}
    \label{rmk:the-only-path-is-refl}
    直观地, 自然数的归纳原理表示, 所有自然数要么是 $0$, 要么是构造 $\suc(n)$ 的构造, 其中 $n$ 也是自然数, 因此只要证明这两种情况(并在第二种情况使用归纳猜想), 那么就能证明所有自然数的性质.
    类似的, $A+B$ 的归纳原理表示了, $A+B$ 的元素都是 $\inl(a)$ 或 $\inr(b)$ 的形式, 依此类推.
    把同样的观点应用到路径归纳, 可以说路径归纳表示了, 所有路径都是 \refl{a} 的形式, 所以只需证明自反的性质, 就证明了所有路径的性质.

    不过, 路径的同伦理论内容非常令人困惑, 比如可能有很多方法来证明 $a$ 和 $b$ 是恒等的, 因此恒等类型会有很多元素!
    归纳原理主张只有自反这一个路径, 那么怎么会有一些不同的路径?

    关键在于是被归纳定义的不是恒等\emph{类型}, 而是恒等\emph{族}.
    特别的, 路径归纳说明, 类型 $(\id[A]{x}{y})$ 的\emph{族},  当 $x,y$ 变成 $A$ 类型的其他元素是, 是通过 $\refl{x}$ 形式的元素归纳定义的.
    这意味, 为了给出另一个族 $C(x,y,p)$ 的一个元素, 其中它依赖\emph{泛型}元素 $(x,y,p)$, 只需考虑形式 $(x,x,\refl{x})$ 的情况即可.
    在同伦的解释中, 这表示了三元对 $(x,y,p)$, 其中 $x$ 和 $y$ 是路径 $p$ 的端点(即 $\Sigma$-type $\sm{x,y:A}(\id{x}{y})$), 是在每个点 $x$ 的常量环圈常量\index{路径!常量}归纳生成的.
    正如 \cref{cha:basics} 所见, 在同论论中, $\sm{x,y:A}(\id{x}{y})$ 相当于 \emph{自由路径空间} --- 是一个端点在 $A$ 中并且会变化的空间 --- 事实上这种情况这个空间同伦于一些点上的常量环圈, 因此我们可以简单地收缩其中一个端点沿着给定路径.
    类似的事实在类型论中也适用: $p:x=y$ 的路径归纳可以证明 $\id[\sm{x,y:A}(\id{x}{y})]{(x,y,p)}{(x,x,\refl{x})}$.

    类似的, 基础归纳类型说明固定一个 $a:A$, 而元素 $y$ 在 $A$ 自由变化, 类型 $(\id[A]{a}{y})$ 的\emph{族}, 被元素 $\refl{a}$ 归纳定义.
    因此, 为了给出另一个族 $C(y,p)$ 的一个元素, 其中它依赖泛型元素 $(y,p)$, 只需考虑 $(a,\refl{a})$ 的情况.
    同伦上, 这表示了路径的空间开始于一些选定的点 (这个点上的\emph{基本路径空间}, 即类型论中的 $\sm{y:A} (\id{a}{y})$), 并可收缩于选定点的常量环圈.
    同样, 类似的事实在类型论中也适用: $p:a=y$上的基本路径归纳可以证明 $\id[\sm{y:A}(\id{a}{y})]{(y,p)}{(a,\refl{a})}$.
    注意也可以通过 \cref{sec:pat} 中提及的 $\Sigma$-types 是一个子类型来理解, 类型 $\sm{y:A}(\id{a}{y})$ 可以当作 ``所有 类型为 $A$ 且与 $a$ 相等的元素'', 即类型论中的``单元素\index{类型!单元素}子集'' $\{a\}$.

    路径归纳与基本路径归纳都提供了一个方法, 来给定族 $C(p)$ 的元素, 其中 $p$有\emph{两个固定端点} $a$ 和 $b$.
    特别的, 因为 $C: (\id[A]{a}{a}) \to \UU$ 依赖一个环圈, 我们\emph{不能}应用路径归纳而考虑唯一 $C(\refl{a})$ 的唯一情况, 因此我们不能证明所有环圈是自反的.
    因此, 归纳定义恒等族时, 不禁止非自反路径作为特殊的恒等类型的实例.
    换句话说, 路径 $p:\id{x}{x}$ 可能和 $(\id{x}{x})$ 的元素自反不相等, 但是对子 $(x,p)$ 和 $\sm{y:A}(\id{x}{y})$ 的 $(x,\refl{x})$ 是相等的.

    举个拓扑学的例子, 考虑一个穿孔圆环中的环圈\narrowequation{\setof{ (x,y) | 0 < x^2+y^2 < 2 }}, 起点为 $(1,0)$ 而围绕空洞 $(0,0)$ 到终点 $(1,0)$.
    如果把端点都固定为 $(1,0)$, 当没有这个穿孔圆环时, 这个环圈就不能变形为常量路径.
    就像只要抓住绳子两端, 绳子就不能拉动.
    不过, 如果允许一个端点变化, 环圈又可以收缩为常量, 就像只要抓住一端, 就可以拾起一条绳子.
\end{rmk}

\index{路径!归纳|)}%
\index{归纳原理!恒等类型的|)}%
\index{generation!类型的, 归纳|)}

\subsection{路径归纳和基本路径归纳的等效性}

之前引入的这恒等类型的递归原理是等效的.
显而易见路径归纳来自基本路径归纳原理.
的确, 假定路径归纳的前提:
\begin{align*}
    C &: \prd{x,y:A}(\id[A]{x}{y}) \to \UU,\\
    c &: \prd{x:A} C(x,x,\refl{x}).
\end{align*}
现在, 给定一个元素 $x:A$, 实例化上面的式子, 得到
\begin{align*}
    C' &: \prd{y:A} (\id[A]{x}{y}) \to \UU, \\
    C' &\defeq C(x), \\
    c' &: C'(x,\refl{x}), \\
    c' &\defeq c(x).
\end{align*}
清晰的, $C'$ 和 $c'$ 匹配基本路径归纳的前提, 由此可以构造
\begin{equation*}
    g : \prd{y:A}{p : \id{x}{y}} C'(y,p)
\end{equation*}
与这个定义等同 \[ g(x,\refl{x}) \defeq c'.\]
现在我们观察到 $g$ 的到达域等于 $C(x,y,p)$.
因此, 履行假设 $x:A$, 派生函数 \[ f : \prd{x,y:A}{p : \id[A]{x}{y}} C(x,y,p) \]
与所需要的判断等同 $f(x,x,\refl{x}) \judgeq g(x,\refl{x}) \defeq c' \defeq c(x)$.

另一种证明这个事实的方法是, $f$ 可以从 $\indidb{A}$ 的一个实例中得到, 所以知道用 $\indidb{A}$ 的项定义 $\indid{A}$ 即可: \[ \indid{A}(C,c,x,y,p) \defeq \indidb{A}(x,C(x),c(x),y,p). \]

第二种方法有一些巧妙;
对于如何用特定的路径归纳的实例来派生特别的基础路径归纳, 有一点不清晰.
我可以构造阿一个路径归纳的实例, 它一次显示基础归纳类型所有可能的实例.
定义
\begin{align*}
    D &: \prd{x,y:A} (\id[A]{x}{y}) \to \UU, \\
    D(x,y,p) &\defeq \prd{C : \prd{z:A} (\id[A]{x}{z}) \to \UU} C(x,\refl{x}) \to C(y,p).
\end{align*}
然后可以构造函数
\begin{align*}
    d &: \prd{x : A} D(x,x,\refl{x}), \\
    d &\defeq \lamu{x:A}\lamu{C:\prd{z:A}{p : \id[A]{x}{z}} \UU}\lam{c:C(x,\refl{x})} c
\end{align*}
然后使用路径归纳得到 \[ f : \prd{x,y:A}{p:\id[A]{x}{y}} D(x,y,p) \]
与 $f(x,x,\refl{x}) \defeq d(x)$.
展开定义中的 $D$, 把类型$f$ 详述为: \[ f : \prd{x,y:A}{p:\id[A]{x}{y}}{C : \prd{z:A} (\id[A]{x}{z}) \to \UU} C(x,\refl{x}) \to C(y,p). \]
现在给定 $x:A$ 和 $p:\id[A]{a}{x}$, 可以派生基本路径归纳的结论: \[ f(a,x,p,C,c) : C(x,p). \]
注意还得到正确的定义等同.

另一个证明是,  观察到任何基本路径的递归的使用都是 $\indidb{A}$ 的实例, 然后定义
\begin{narrowmultline*}
    \indidb{A}(a,C,c,x,p) \defeq \narrowbreak
    \indid{A}
    \begin{aligned}[t]
        \big(
        &\big(\lamu{x,y:A}{p:\id[A]{x}{y}} \tprd{C : \prd{z:A} (\id[A]{x}{z}) \to \UU} C(x,\refl{x}) \to C(y,p) \big),\\
        &(\lamu{x:A}{C:\prd{z:A} (\id[A]{x}{z}) \to \UU}{d:C(x,\refl{x})} d),
        a, x, p, C, c \big).
    \end{aligned}
\end{narrowmultline*}


注意上面的构造避免了宇宙.
也就是说, 如果想要为 $\indidb{A}$ 建模为 $C : \prd{x:A} (\id[A]{a}{x}) \to \UU_i$, 需要使用 $\indid{A}$ 其中
\[
    D:\prd{x,y:A} (\id[A]{x}{y}) \to \UU_{i+1}
\]

因为 $D$ 用量词限定了所有给定类型的 $C$.
虽然这是宇宙定义的一致性, 但也也可以在不使用宇宙的情况下派生 $\indidb{A}$: 可以证明 $\indid{A}$ 包含 \cref{lem:transport,thm:contr-paths}, 而这两个原则直接表明 $\indidb{A}$.
细节在 \cref{ex:pm-to-ml}.

使用上述恒等类型的表述等同是等效性关系, 即每个函数保持等同的, 和每个族分别相等.
下一章有这些细节, 并在同论类型论的语境中进行介绍和解释.

\begin{rmk}
    \label{rmk:propeq-vs-jdeq}
    我们强调尽管有一些不熟悉的特征, 命题等同就是\emph{这个}同伦类型论中的数学等同.
    这种区别不属于判断等同, 而是类型伦规则的一种原理伦特征.
    例如, \cref{sec:inductive-types} 中自然数加法的结合律, 是\emph{命题的}等同, 而不是一个判断等同.
    交换律也是如此(\cref{ex:add-nat-commutative}).
    即使是简单的交换 $n+1=1+n$ 对于一个通用的 $n$ 而言也不是判断等同(尽管对于特定的 $n$ 是判断性的, 例如 $3+1\jdeq 1+3$, 虽然者通过 $+$ 的计算规则都判断等同于 $4$).
    只能从恒等类型来证明类似事实, 因为只能应用 \nat 的归纳原理并返回一个类型 (而不是判断).
\end{rmk}

\subsection{严格不等}
\label{sec:disequality}

最后谈谈\define{严格不等},
\indexdef{严格不等}%
也就是等同的否定:
\footnote{我们使用``不等''%
来表示 $<$ 和 $\leq$. 另外, 注意这是恒等类型\emph{命题}的否定.
当然,否定判断等同 $\jdeq$ 是没有意义的, 因为判断不是一种逻辑操作.} %

\begin{equation*}
(x \neq_A y)
    \ \defeq\ \lnot (\id[A]{x}{y}).
\end{equation*}
若 $x\neq y$, 说 $x$ 和 $y$ 是\define{不等于}.\indexdef{不等于}%

和否定一样, 严格不等在这里没有在经典的\index{数学!经典的}数学那么重要.
例如, 不能通过证明两个东西不是不等的来证明他们相等: 这需要应用经典的双重否定法则, 参见 \cref{sec:intuitionism}.

有时严格不等也有用.
例如, 在~\cref{RD-inverse-apart-0}将证明实数 $x$ 有一个倒数, 当且仅当它与~$0$ 的距离是正数, 这比 $x \neq 0$ 的条件更强.

\index{类型!恒等|)}%