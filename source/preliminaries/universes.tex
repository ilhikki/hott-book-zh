迄今为止还在非形式地使用表达式``$A$ 是一个类型''.
现在通过介绍\define{全集}让它更严谨.
\index{类型!全集|(defstyle}%
\indexsee{全集}{类型, 全集}%
全集是一个类型, 它的元素也是类型.
在朴素的集合论中, 希望有一个包含所有类型的全集 $\UU_\infty$, 也包含它自己(也就是 $\UU_\infty : \UU_\infty$).
不过, 在集合论中这是不可靠的, 例如, 可以由它演绎出所有类型, 包括代表命题为假的空类型 (参见 \cref{sec:coproduct-types}) 也有居留元.
例如, 把集合作为树, 可以直接编写出罗素悖论\index{悖论}\cite{coquand:paradox}.

%%%  or alternatively, in order to avoid the use of
% inductive types to define trees, we can follow Girard \cite{girard:paradox} and encode the Burali-Forti paradox,
% which shows that the collection of all ordinals cannot be an ordinal.
为了避免这个悖论, 引入全集的等级结构
\indexsee{等级结构!全集}{类型, 全集}%
\[ \UU_0 : \UU_1 : \UU_2 : \cdots \]
每个全集 $\UU_i$ 都是下一个等级的全集 $\UU_{i+1}$ 的元素.
此外, 假定全集是\define{累积的},
\indexdef{类型!全集!累积}%
\indexdef{累积!全集}%
也就是说 $i^{\mathrm{th}}$ 全集的所有元素也是 $(i+1)^{\mathrm{st}}$ 全集的元素, 即, 如果 $A:\UU_i$ 那么 $A:\UU_{i+1}$.
方便的同时有一些稍微不令人愉快的结果, 元素不再具有唯一的类型, 并且在别的地方有一点棘手, 不过这里不需要关心;
参见备注.

当我们说 $A$ 是一个类型, 意味着它居留于某些 $\UU_i$.
通常避免显式提及等级
\indexdef{全集等级}%
\indexsee{等级}{全集的等级 或者 $n$-类型}%
\indexsee{类型!全集!等级}{全集 等级}%
$i$, 而是假定它的等级已经被一致的方式分配;
因此可以忽略它的等级, 记作 $A:\UU$.
按照这样的方式, 甚至可以写出 $\UU:\UU$, 它被看作 $\UU_i:\UU_{i+1}$, 隐式地包含了索引.
这种编写全集的风格被称为\define{类型的歧义}.
\indexdef{类型的歧义}%
它方便而略有危险, 因为可以写出看起来合法的证明, 制造自指的悖论.
如果对参数是否准确有疑问, 检查的方法是, 尝试为所有出现的全集一致地分配等级.
当某些全集 \UU 被假定, 可以把属于 \UU 的类型称为\define{小类型}.
\indexdef{小!类型}%
\indexdef{类型!小}%

给定类型 $A$, 要为随之变化的类型建模, 可以使用函数 $B : A \to \UU$, 它的到达域是一个全集.
这些函数被称为\define{类型族}%
(也叫\emph{依值类型});
\indexsee{族!类型}{类型, 族}%
\indexdef{类型!族}%
\indexsee{类型!依值}{类型, 族}%
\indexsee{依值!类型}{类型, 族}%
在集合论中, 它们相当于集合中的集合族.

\symlabel{fin}
类型族的一个例子是, 有限集的族 $\Fin : \nat \to \UU$, 其中 $\Fin(n)$ 是一个类型, 恰好有 $n$ 个元素.
(还无法\emph{定义}族 $\Fin$ --- 的确, 还没有介绍它的定义域 $\nat$ --- 但是马上会介绍;
参见 \cref{ex:fin}.)
可以通过 $0_n,1_n,\dots,(n-1)_n$ 表示 $\Fin(n)$, 它的下标强调了如果 $n$ 和 $m$ 不同,  $\Fin(n)$ 的元素与 $\Fin(m)$ 的元素也不同, 而且所有的元素和普通的自然数都不同
(在 \cref{sec:inductive-types} 会介绍自然数).
\index{有限!集合, 族}%


更琐碎(但非常重要)的类型族的一个例子是, 类型 $B:\UU$ 上的\define{常量}类型族,
\indexdef{常量!类型族}%
\indexdef{类型!的族!常量}%
即常量函数 $(\lam{x:A} B):A\to\UU$.

作为一个\emph{非}示例, 这个版本的类型论中, 没有类型族 ``$\lam{i:\nat} \UU_i$''.
实际上, 没有足够大的全集可以作为它的到达域.
此外不用类型论中的自然数 \nat (\cref{sec:inductive-types} 中引入), 来标识全集 $\UU_i$ 的下标 $i$.

\index{类型!全集|)}