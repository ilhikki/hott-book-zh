\index{命题!作为类型|(defstyle}%
\index{逻辑!命题作为类型|(}%
就像在导论里提及的那样, 在类型论中, 表示一个命题为真, 相当于给出一个对应类型, 和这个类型的一个居留元. \index{证据, 命题为真的}%
\index{见证!命题为真的}%
\index{证明|(}
我们把这个元素视为\emph{证据}, 或者是命题为真的\emph{见证}. (有时会把它们称为\emph{证明}, 不过这个术语是误导性的, 所以我们避免提及.)不过我们一般不会直接地构造见证; 而是以普通的数学散文形式提供证明, 然后翻译成类型元素的方法. 这和经典的集合论没有区别, 但是我们不希望出现断言逻辑规则和类型论的公理. 

类型论关于证明的观点, 在一些重要的方面, 是与众不同的. 类型论中的基本的逻辑的原理是, 命题不是非真即假, 命题是一个汇集, 包含了所有它为真的见证. 从这个角度看, 证明不仅仅是数学推理的过程, 证明本身也是一个数学对象, 与熟悉的对象(例如数字, 映射, 群等) 一样。因此, 类型划分了可获得的数学对象, 并决定它们如何交互, 所以命题只是特殊的类型 --- 即类型, 且它的元素为证明. 

\index{命题的!逻辑}%
\index{逻辑!命题的}%
可行的方法是, 对于自然语言表达的\emph{逻辑}命题, 和\emph{类型论}中对应见证的类型, 我们有如下对应关系. \index{假}%
\index{真}%
\index{连词}%
\index{析取}%
\index{蕴涵}%
\begin{center}
\medskip
\begin{tabular}{ll}
\toprule
自然语言 &类型论\\
\midrule
真 &$\unit$ \\
假 &$\emptyt$ \\
$A$ 且$B$ &$A \times B$ \\
$A$ 或 $B$ &$A + B$ \\
若 $A$ 则 $B$ &$A \to B$ \\
$A$ 当且仅当 $B$ &$(A \to B) \times (B \to A)$ \\
非 $A$ &$A \to \emptyt$ \\
\bottomrule
\end{tabular}
\medskip
\end{center}

每种情况, 右边的类型的构造和使用其元素的规则对应左边的命题推理规则. 例如, 为了构造陈述句 ``$A$ 且 $B$'' 的证明, 基本方法是: 分别证明 $A$ 和 $B$; 与之对应的是, 构造 $A\times B$ 的一个元素 $(a,b)$, 其中 $a$ 是一个 $A$ 的元素 (或者见证) 而 $b$ 是一个 $B$ 的元素 (或者见证). 由 ``$A$ 且 $B$'', 并自由使用 $A$ 和 $B$ 来证明其它东西; 与之对应的是 $A\times B$ 的归纳原理, 即构造一个使用元素 $A$ 和 $B$ 的函数. 

类似的, 为了证明一个蕴含\index{蕴含} ``若 $A$ 则 $B$'', 基本方法是: 假设 $A$ 并证明 $B$; 与之对应的是, 构造元素 $A\to B$, 即给定一个表达式, 这个表达式返回一个 $B$ 的元素 (见证), 并可以包含类型为 $A$的变量元素 (见证). 使用一个蕴含 ``如果 $A$ 那么 $B$'' 的基本方法是: 如果我们知道 $A$ 则可以演绎出 $B$; 与之对应的是, 应用函数基本方法, 即应用 $f:A\to B$ 到一个元素 $A$ 来产生类型为 $B$ 的元素. 我们强烈建议读者做这个练习, 将其它类型构造器的规则转换为逻辑. 

特别的, 空类型 $\emptyt$ 对应错误.\index{假} 我们把 $\emptyt$ 的居留元称为逻辑学中\define{矛盾}: \indexdef{矛盾}%
因此无法证明一个矛盾, \footnote{更准确地说, 没有\emph{基础}的方法来证明一个矛盾, 即 \emptyt 没有构造器.%
如果我们的类型论是不一致的, 那么会有一些复杂的方法来构造 \emptyt 的元素.}而从一个矛盾我们可以派生任何东西. 我们也可以定义类型的 $A$ 的\define{否定}, \indexdef{否定}%
即 %

\begin{equation*}
\neg A \ \defeq\ A \to \emptyt.
\end{equation*}
%
因此, $\neg A$ 的见证是一个函数 $A \to \emptyt$, 相当于假设 $x : A$ 并构造一个 $\emptyt$ 元素. \index{证明!通过矛盾}%
\index{逻辑!构成主义的与经典的}
注意尽管我们得到的逻辑是``构成主义的'', 就像在导论里讨论的一样, 这种 ``反正法'' 的方式(假设 $A$ 则派生一个矛盾, 得出结论 $\neg A$) 是完全有效的构造: 它只是调用``否定''的 \emph{含义}. 这种 ``通过矛盾来证明'' 的方式不允许假设 $\neg A$, 并派生出矛盾, 来证明 $A$. 构成主义中, 这样的论点只允许我们得出结论 $\neg\neg A$, 而读者可以校验, 明显不存在构造 $\neg\neg A$ (即, 从 $(A\to \emptyt)\to\emptyt$) 到 $A$ 的方式. 

\mentalpause

以上这些从逻辑关系到类型构造操作的转换, 被称为\define{命题作为类型}: 提供了一种, 可以把自然语言书写的的命题与其证明, 转为类型和与其元素的方法. 例如, 要证明下面的重言式(``德摩根定律''之一): \index{定律!德摩根的|(}%
\index{德摩根定律|(}%
\begin{equation}\label{eq:tautology1}
\text{\emph{``如果非 $A$ 且非 $B$, 那么非 ($A$ 或 $B$)''}.}
\end{equation}
一个普通的自然语言的证明可能如下 \begin{quote}
假设非 $A$ 且非 $B$, 并假设 $A$ 或 $B$; 我们可以派生一个矛盾.
有两种情况.
如果 $A$ 成立,那么因为非 $A$, 我们得到一个矛盾.
类似的, 如果 $B$ 成立, 那么非 $B$, 我们也得到矛盾.
因此我们在每种情况下都得到矛盾, 所以非 ($A$ 或 $B$).
\end{quote}
现在, 与重言式~\eqref{eq:tautology1} 对应的类型, 被这个规则给定, 即 \begin{equation}\label{eq:tautology2}
(A\to \emptyt) \times (B\to\emptyt) \to (A+B\to\emptyt)
\end{equation}
于是可以将以上证明, 转换为这个类型的元素. 

作为一个如何转换的例子, 类似于数学家如何根据上文描述的自然语言, 在脑海中构造一个 \eqref{eq:tautology2} 的元素. 短语 ``如果非 $A$ 且非 $B$''可以转换为, 定义一个函数, 它隐式应用笛卡尔集的归纳原理到它的定义域  $(A\to\emptyt)\times (B\to\emptyt)$. 这里引入了两个未命名变量\index{变量}%
(猜想) \index{猜想}%
, 类型为 $A\to\emptyt$ 和 $B\to\emptyt$. 为了转换到类型论, 必须给这些变量取一个名字; 比如说 $x$ 和 $y$. 至此, \eqref{eq:tautology2} 的元素的部分定义可以写做 \[ f((x,y)) \defeq\; \Box\;:A+B\to\emptyt \]
其中类型 $A+B\to\emptyt$ 的``空洞'' $\Box$ 指出还需被完成的部分. (也可以通过使用递归子代替模式匹配, 写出等效的 $f \defeq \rec{(A\to\emptyt)\times (B\to\emptyt)}(A+B\to\emptyt,\lam{x}{y} \Box)$.) 第二句短语``并假设 $A$ 或 $B$; 我们可以派出生一个矛盾'', 意味通过函数定义来填充这个空洞, 于是引入另一个未命名的猜想 $z:A+B$, 得到证明: \[ f((x,y))(z) \defeq \;\Box\; :\emptyt. \]
``有两种情况'', 表示了情况区分, 即使用陪积 $A+B$的递归原理. 如果使用递归子, 就是  \[ f((x,y))(z) \defeq \rec{A+B}(\emptyt,\lam{a} \Box,\lam{b}\Box,z) \]
而如果我们使用模式匹配来缩写, 那就是 \begin{align*}
f((x,y))(\inl(a)) &\defeq \;\Box\;:\emptyt\\
f((x,y))(\inr(b)) &\defeq \;\Box\;:\emptyt.
\end{align*}
注意这两种情况下, 都需要填充类型 $\emptyt$ 的两个``空洞'', 相当于两种情况下都必须派生矛盾. 最后, 只要应用函数 $x$ 到 $a$, 即可得从矛盾 $a:A$ 则 $x:A\to\emptyt$ 得到结论, 另一种情况也类似. \index{应用!猜想或定理的}%
(注意``应用函数'' 与 ``应用猜想或者定理''这个两个短语的方便的巧合.) 因此我们最终的定义是 \begin{align*}
f((x,y))(\inl(a)) &\defeq x(a)\\
f((x,y))(\inr(b)) &\defeq y(b).
\end{align*}

习题: 使用刚才介绍的规则, 校验重言式: 对于任何 $A$ 和 $B$ \emph{``如果非 ($A$ 或 $B$), 那么(非 $A$)且(非 $B$)}'', 即从类型 \[ ((A + B) \to \emptyt) \to (A \to \emptyt) \times (B \to \emptyt), \]
给出一个居留元素. 

\index{逻辑!经典的与构成主义的|(}
不过, 不能这样理解所有的经典\index{数学!经典的}重言式. 例如, 无法校验规则 \emph{``若非 ($A$ 且 $B$), 则(非 $A$) 或 (非 $B$)''}: 一般情况下, 无法构造下面这个类型的元素
\[ ((A \times B) \to \emptyt) \to (A \to \emptyt) + (B \to \emptyt).\]
它反映的事实是, 在类型论中, 命题作为类型的自然逻辑是\emph{构造主义的}. 这意味它不一定包括某些经典原理, 比如排中论 (\LEM{})\index{排中}和反证法,\index{证明!反证} 以及依赖于它们的其它原理, 例如德摩根定律. \index{定律!德摩根的|)}%
\index{德摩根定律|)}%

在哲学上, 被称为构成主义逻辑的原因是, 它自律于构造, 并贯彻计算意义上的\emph{有效性}. 不准确地说, 存在一个如何一步步地构造一个对象(和如何确定一个定理是否正确)的具体的算法\index{算法}. 所以需要忽略 \LEM{}, 因为这样就没有\emph{有效的}\index{有效的!步骤}步骤来判定一个命题是真还是假. 

构成主义的类型论逻辑意味着, 它具备计算意义上的本质, 这正是计算机学家所感兴趣的. 这也意味类型论提供了\emph{公理自由度}.\index{公理自由度} 例如, 虽然默认的构成主义没有 \LEM{}, 逻辑仍然是完备的(参见 \cref{sec:intuitionism}). 因此, 类型论不\emph{否认} \LEM{}, 我们可以考虑把它作为假设添加, 然后按惯例运行并不受限制. 在这个方面, 类型论丰富了, 而不是限制了常规的数学实践. 

我们建议不熟悉构成主义逻辑的读者尝试更多的示例, 以此来熟悉它. 参见 \cref{ex:tautologies,ex:not-not-lem} 中的一些建议. \index{逻辑!经典的与构成主义的|)}

\mentalpause

迄今为止仅讨论了命题逻辑. \index{量化}%
\index{量化!构成的}%
\index{量化!普遍的}%
\index{判断式!逻辑}%
\index{逻辑!判断式}%
现在来考虑\emph{断言}逻辑, 除了逻辑连词``且''和``或'' , 我们还有量词 ``存在'' 和``所有''. 这种情况下, 类型具有双重角色: 它既可以作为命题, 也可以作为常规意义的类型, 例如被量化的定义域. 类型族 $P : A \to \UU$ 表示一个在 $A$ 上的断言, 而赋值一个元素 $a : A$ 得到类型 $P(a)$, 相当于命题 $P$ 对于 $a$ 成立. 现在通过量词来扩展之前的转换方式 \begin{center}
\medskip
\begin{tabular}{ll}
\toprule
自然语言 &类型论\\
\midrule
对于所有 $x:A$, $P(x)$ 成立 &$\prd{x:A} P(x)$ \\
存在 $x:A$ 有 $P(x)$ &$\sm{x:A}$ $P(x)$ \\
\bottomrule
\end{tabular}
\medskip
\end{center}
和之前一样, 可以展示(构成主义的)断言逻辑重言式转换为被居留类型. 例如, \emph{如果对于所有 $x:A$, $P(x)$ 和 $Q(x)$ 那么(对于所有 $x:A$, $P(x)$) 且(对于所有 $x:A$, $Q(x)$)}, 可以转换为 \[ (\tprd{x:A} P(x) \times Q(x)) \to (\tprd{x:A} P(x)) \times (\tprd{x:A} Q(x)). \]
一个非正式的证明如下: \begin{quote}
假设对于所有 $x$, $P(x)$ 和 $Q(x)$.
第一步, 假设给定 $x$ 和证明 $P(x)$.
通过假设, 有 $P(x)$ 和 $Q(x)$, 因此有 $P(x)$.
第二步, 假设给定 $x$ 和证明 $Q(x)$.
同样通过假设, 有 $P(x)$ 和 $Q(x)$, 因此有 $Q(x)$.
\end{quote}
第一步的句子把蕴含定义为一个函数, 通过引入其猜想的见证:\index{猜想} \[ f(p) \defeq \;\Box\; : (\tprd{x:A} P(x)) \times (\tprd{x:A} Q(x)). \]
在这里, 为了产生一个乘积类型的元素, 隐式地使用了对子的构造器, 在例子中就是单词``第一步''和``第二步''的使用: \[ f(p) \defeq \Big( \;\Box\; : \tprd{x:A} P(x) \;,\; \Box\; : \tprd{x:A}Q(x) \;\Big). \]
短语 ``假设给定 $x$ 和证明 $P(x)$'' 现在表示为以通常的方式定义\emph{依赖}函数, 即引入它输入的变量 \index{变量}%
 因为它位于对子的构造器中, 通常把它些为 $\lambda$-abstraction\index{lambda abstraction@$\lambda$-abstraction}: \[ f(p) \defeq \Big( \; \lam{x} \;\big(\Box\; : P(x)\big) \;,\; \Box\; : \tprd{x:A}Q(x) \;\Big). \]
现在引用``有 $P(x)$ 和 $Q(x)$''这个猜想, 得到 $p(x) : P(x)\times Q(x)$, 而 ``因此我们有$P(x)$'' 隐式地调用了投影: \[ f(p) \defeq \Big( \; \lam{x} \proj1(p(x)) \;,\; \Box\; : \tprd{x:A}Q(x) \;\Big). \]
显而易见, 第二步的两个句子可以填充另一个空洞: \[ f(p) \defeq \Big( \; \lam{x} \proj1(p(x)) \;,\; \lam{x} \proj2(p(x)) \; \Big). \]
当然, 作为示例的自然语言的证明比数学家在实践中使用的证明更加冗长; 它更像``证明导论''课里面使用的那种语言. 实际上数学家已经学会了填补空白, 所以实践中可以省略很多细节. 不过, 证明的有效性的标准还是是否能将证明转换为对应元素的构造. 

\symlabel{leq-nat}%
一个更加实用的例子, 如何定义自然数的不等式. 一个自然的定义是, 若存在 $k:\nat$ 使得 $n+k=m$, 则 $n\le m$. (这里又使用到了等同类型, 而我们在下一节介绍它, 但是我们不需要特别了解它.) 在命题作为类型的翻译上, 可以给出: \[ (n\le m) \defeq \sm{k:\nat} (\id{n+k}{m}). \]
我们邀请读者: 从这个定义, 来证明这个熟悉的 $\le$  的特性. 对于严格不等式, 有几种自然的选择, 比如说 \[ (n<m) \defeq \sm{k:\nat} (\id{n+\suc(k)}{m}) \]
和 \[ (n<m) \defeq (n\le m) \times \neg(\id{n}{m}). \]
前者在构造主义数学中更自然, 其实在这种情况下两者是等效的, 因为 $\nat$ 具有 ``可判定的等同'' (参见 \cref{sec:intuitionism,prop:nat-is-set}). \index{可判定的!等同}%

还可以这样理解类型 $\sm{x:A} P(x)$. 因为它的一个居留元是， 一个元素 $x:A$ 与一个 $P(x)$ 成立的见证, 而不是把 $\sm{x:A} P(x)$ 当作命题 ``存在 $x:A$ 使得 $P(x)$'', 我们可以把它视为``所有满足 $P(x)$ 的元素 $x:A$ 的类型'', 例如作为 $A$ 的``子类型'' \index{子类型}%

我们会在 \cref{subsec:prop-subsets} 给出子类型的解释. 现在, 我们注意到到, 它允许我们把公理纳入类型定义, 作为我们在 \cref{sec:sigma-types} 讨论的数学结构. 例如, 要定义一个\define{半群}\index{半群}, 即一个类型 $A$ 与一个二元操作符 $m:A\to A\to A$ (即, 原群\index{原群}), 而且对于所有 $x,y,z:A$ 有 $m(x,m(y,z)) = m(m(x,y),z)$. 第二被命题可以被表示为 \[\prd{x,y,z:A} m(x,m(y,z)) = m(m(x,y),z),\]
所以半群的类型是 \[ \semigroup \defeq \sm{A:\UU}{m:A\to A\to A} \prd{x,y,z:A} m(x,m(y,z)) = m(m(x,y),z), \]
也就是说 半群是 $\mathsf{Magma}$ 的子类型. 在 $\semigroup$ 的一个居留元上应用投影, 可以抽取载体 $A$, 操作符 $m$, 和一个公理的见证. 在 \cref{sec:equality-of-structures} 会回到这个例子. 

注意, 借助类型论中的宇宙, 可以表示 ``高阶逻辑'' --- 即可以量化所有的命题或者断言. 例如, 可以把 \emph{对于所有性质 $P : A \to \UU$, 若 $P(a)$ 则 $P(b)$} 表现为 \[ \prd{P : A \to \UU} P(a) \to P(b) \]
其中 $A : \UU$ 而 $a,b : A$. 不过, \emph{先验的}, 这个命题的宇宙与原来的不同, 等级比量化前的命题更高; 也就是 \[ \Parens{\prd{P : A \to \UU_i} P(a) \to P(b)} : \UU_{i+1}. \]
在 \cref{subsec:prop-subsets} 会回到这个问题. 

\mentalpause

我们描述了``证明相关'' 的\index{数学!证明相关}%
命题的转换, 其中这些逻辑析取与构成语句的证明携带着一些信息. 例如, 如果有一个 $A+B$ 的居留元, 被当作一个 ``$A$ 或 $B$'' 的见证, 那么我们可以知道它来自于 $A$ 或者 $B$. 类似的, 如果有 $\sm{x:A} P(x)$  的居留元, 被当作一个 ``存在一个 $x:A$ 满足 $P(x)$'' 的见证, 那么可以知道元素 $x$ (通过给定居留元元的第一投影). 

作为逻辑性质相关证明的结果, 可以有``$A$ 当且仅当 $B$'' (回想 $(A\to B)\times (B\to A)$), 不过 $A$ 和 $B$ 表现的行为不同. 例如, 容易校验 ``$\mathbb{N}$ 当且仅当 $\unit$'', 而显然 $\mathbb{N}$和 $\unit$ 有重要不同. 陈述句 ``$\mathbb{N}$ 当且仅当 $\unit$'' 告诉我们 \emph{作为一个纯命题时}, 类型 $\mathbb{N}$ 才能表现为同样是命题的 $\unit$ (真命题). 有时把 ``$A$ 当且仅当 $B$'' 表示为 $A$ 和 $B$ 是\define{逻辑等价}的. \indexdef{逻辑等价}%
\indexdef{等价!逻辑}%
它有别于在  \cref{sec:basics-equivalences,cha:equivalences} 中引入的更强概念, 即 \emph{类型的等价}: 尽管 $\mathbb{N}$ 和 $\unit$ 是逻辑等价的, 但是它们 不是等价类型. 

在\cref{cha:logic} 会引入一种叫做 ``纯命题'' 的类型, 它们的类型等价和逻辑等价一致. 使用这些类型, 会对上面的逻辑进行适当修改,  丢弃包含在析取和构造中的附加信息. 

最后注意, 可以把命题作为类型反过来, 把任意类型 $A$ 当作一个命题, 而展示 $A$ 的居留元来证明这一点. 有时这个命题被陈述为 ``$A$ 是\define{被居留的}''. \indexdef{被居留类型}%
\indexsee{类型!被居留}{被居留类型}%
也就是, 当我们说 $A$ 被居留, 我们意味我们需要给定一个(特定的) $A$ 的元素, 但是我们不需要给这个元素取一个名字. 类似的, 为了表示 $A$ 是\emph{不被居留的}, 等同于给定一个 $\neg A$ 的元素. 特别的, 空类型 $\emptyt$ 显然没有居留元, 因为 $\neg \emptyt \jdeq (\emptyt \to \emptyt)$ 的居留元是 $\idfunc[\emptyt]$.\footnote{这和类型论是一致的陈述没有矛盾, 因为\emph{元理论}主张无法通过遵循类型论的规则来获得 $\emptyt$.\indexfoot{consistency}} 

\index{证明|)}%
\index{命题!作为命题|)}%
\index{逻辑!命题作为类型|)}%