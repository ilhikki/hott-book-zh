\index{命题!作为类型|(defstyle}%
\index{逻辑!命题即类型|(}%
正如导论所提及, 类型论中, 要展示一个命题为真, 相当于给出对应类型的一个居留元. \index{证据, 命题为真的}%
\index{见证!命题为真的}%
\index{证明|(}
这个元素被视为\emph{证据}, 或者是命题为真的\emph{见证}.
(有时会把它们称为\emph{证明}, 不过这个术语有误导性, 所以通常避免它.)
不过, 通常不会显式地构造见证;
而是以普通的数学文章的形式提供证明, 再转换成类型的一个元素.
这和经典的集合论没有区别, 我们不希望看到显式的结论, 并使用断言逻辑规则和类型论的公理.

不过, 在一些重要的方面, 类型论关于证明的观点是与众不同的.
类型论的逻辑, 基本的原理是, 命题不是非真即假, 命题是一个汇集, 包含了所有它为真的见证.
这个概念下, 证明不仅仅是数学推理的过程, 证明本身也是数学对象, 与熟悉的对象(比如数字, 映射, 群等) 平级.
因此, 类型将可获得的数学对象归类, 并决定它们如何交互, 命题只是特殊的类型 --- 即元素为证明的类型.

\index{命题的!逻辑}%
\index{逻辑!命题的}%
使该恒等可行的基本观察是, 自然语言表达的命题\emph{逻辑}运算, 和其对应见证的类型上的\emph{类型论的}运算, 有自然的对应关系如下.
\index{假}%
\index{真}%
\index{连词}%
\index{析取}%
\index{蕴涵}%
\begin{center}
    \medskip
    \begin{tabular}{ll}
        \toprule
        自然语言         & 类型论                          \\
        \midrule
        真            & $\unit$                      \\
        假            & $\emptyt$                    \\
        $A$ 且$B$     & $A \times B$                 \\
        $A$ 或 $B$    & $A + B$                      \\
        若 $A$ 则 $B$  & $A \to B$                    \\
        $A$ 当且仅当 $B$ & $(A \to B) \times (B \to A)$ \\
        非 $A$        & $A \to \emptyt$              \\
        \bottomrule
    \end{tabular}
    \medskip
\end{center}

构造类型和使用其元素的规则(右)对应命题推理规则(左).
例如, 证明语句 ``$A$ 且 $B$'' 的基本方法是: 证明 $A$ 并证明 $B$, 即构造 $A\times B$ 的一个元素 $(a,b)$, 其中 $a$ 是一个 $A$ 的元素(或者见证) 而 $b$ 是一个 $B$ 的元素 (或者见证).
为了使用 ``$A$ 且 $B$'' 来证明其它东西, 可以自由使用 $A$ 和 $B$, 类似于 $A\times B$ 的归纳原理, 允许通过使用元素 $A$ 和 $B$ 来构造其为参数的函数.

类似地, 证明蕴含\index{蕴含} ``若 $A$ 则 $B$'' 的基本方法是: 假设 $A$ 并证明 $B$, 即构造元素 $A\to B$, 给定一个表达式, 这个表达式返回一个 $B$ 的元素 (见证), 可以包含类型为 $A$的变量元素 (见证).
使用一个蕴含 ``如果 $A$ 那么 $B$'' 的基本方法是, 如果知道 $A$ 则可以演绎出 $B$, 类似于函数的应用, 即应用 $f:A\to B$ 于 $A$ 的一个元素来得到类型为 $B$ 的元素.
强烈建议读者练习将其它类型构造器的规则转换为逻辑.

特别注意, 空类型 $\emptyt$ 对应假.
\index{假}%
$\emptyt$ 的居留元被称为逻辑学中\define{矛盾}:
\indexdef{矛盾}%
因此无法证明一个矛盾,
\footnote{更准确地说, 没有\emph{基础}的方法来证明一个矛盾, 即 \emptyt 没有构造器. 如果我们的类型论是非一致的, 那么会有一些复杂的方法来构造 \emptyt 的元素.}%
从一个矛盾可以派生任何东西.
也可以定义类型的 $A$ 的\define{否定}\indexdef{否定}%
\begin{equation*}
    \neg A \ \defeq\ A \to \emptyt.
\end{equation*}
%
于是, $\neg A$ 的见证是 $A \to \emptyt$ 的函数, 相当于假设 $x : A$ 并构造一个 $\emptyt$ 元素.
\index{证明!通过矛盾}%
\index{逻辑!构成主义的与经典的}%
注意尽管得到的逻辑是``构成主义的'', 就像在导论里讨论的一样, 这种 ``反证法'' 的方式(假设 $A$ 则派生一个矛盾, 得出结论 $\neg A$) 是完全的有效构造: 它只是调用``否定''的\emph{含义}.
这种 ``通过矛盾来证明'' 的方式不允许假设 $\neg A$ 并派生出矛盾来证明 $A$.
构成主义中, 只允许断定 $\neg\neg A$, 读者可以校验, 不存在构造 $\neg\neg A$ (即, 从 $(A\to \emptyt)\to\emptyt$) 到 $A$ 的方式.

\mentalpause

上面这些从逻辑关系到类型构造操作的转换, 被称为\define{命题即类型}: 提供了一种把自然语言书写的的命题与其证明, 转为类型和与其元素的方法.
例如, 要证明下面的重言式(``德摩根定律''之一):
\index{定律!德摩根的|(}%
\index{德摩根定律|(}%
\begin{equation}
    \label{eq:tautology1}
    \text{\emph{``如果非 $A$ 且非 $B$, 那么非 ($A$ 或 $B$)''}.}
\end{equation}
一个普通的自然语言的证明可能如下
\begin{quote}
    假设非 $A$ 和非 $B$, 并假设 $A$ 或 $B$; 可以推出矛盾.
    有两种情况. 如果 $A$ 成立,那么因为非 $A$, 得到一个矛盾.
    类似的, 如果 $B$ 成立, 那么因为非 $B$, 也得到矛盾.
    于是在每种情况下都得到矛盾, 所以非 ($A$ 或 $B$).
\end{quote}
现在通过之前给定的规则, 与重言式~\eqref{eq:tautology1} 对应的类型, 就是
\begin{equation}
    \label{eq:tautology2}
    (A\to \emptyt) \times (B\to\emptyt) \to (A+B\to\emptyt)
\end{equation}
于是可以将上面的证明, 转换为这个类型的元素.

作为如何转换的例子, 类似于数学家如何根据上文描述的自然语言, 在脑海中构造一个\eqref{eq:tautology2} 的元素.
短语 ``如果非 $A$ 且非 $B$''可以转换为, 定义一个函数, 在其定义域隐式应用笛卡尔集的归纳原理 $(A\to\emptyt)\times (B\to\emptyt)$.
这里引入了两个未命名变量
\index{变量}%
(猜想)
\index{猜想}%
, 类型为 $A\to\emptyt$ 和 $B\to\emptyt$.
转换到类型论时, 必须给这些变量取一个名字: $x$ 和 $y$.
至此,\eqref{eq:tautology2} 的元素的部分定义可以写作 \[ f((x,y)) \defeq\; \Box\;:A+B\to\emptyt \]
其中类型 $A+B\to\emptyt$ 的``空洞'' $\Box$ 表明还需被完成的部分.
(也可以通过使用递归子代替模式匹配, 等价地写出 $f \defeq \rec{(A\to\emptyt)\times (B\to\emptyt)}(A+B\to\emptyt,\lam{x}{y} \Box)$.)
第二句短语``并假设 $A$ 或 $B$; 可以派生矛盾'', 意味通过函数定义来填充这个空洞, 于是引入另一个未命名的猜想 $z:A+B$, 得到证明: \[ f((x,y))(z) \defeq \;\Box\; :\emptyt. \]
现在, ``有两种情况'', 表示了情况区分, 即余积 $A+B$ 的递归原理的应用.
如果使用递归子, 就是  \[ f((x,y))(z) \defeq \rec{A+B}(\emptyt,\lam{a} \Box,\lam{b}\Box,z) \]
而如果写作模式匹配, 就是
\begin{align*}
    f((x,y))(\inl(a)) &\defeq \;\Box\;:\emptyt\\
    f((x,y))(\inr(b)) &\defeq \;\Box\;:\emptyt.
\end{align*}
注意这两种情况下, 有两个类型 $\emptyt$  的``空洞'' 需要填充, 相当于两种情况下都必须派生矛盾.
最后, 只要应用函数 $x$ 到 $a$, 即可得从矛盾 $a:A$ 则 $x:A\to\emptyt$ 得到结论, 另一种情况也类似.
\index{应用!猜想或定理的}%
(注意``应用函数'' 与 ``应用猜想''或定理这个两个短语的方便的巧合.) 因此最终的定义是
\begin{align*}
    f((x,y))(\inl(a)) &\defeq x(a)\\
    f((x,y))(\inr(b)) &\defeq y(b).
\end{align*}

作为习题, 使用刚才介绍的规则, 校验重言式: 对于任何 $A$ 和 $B$ \emph{``如果非 ($A$ 或 $B$), 那么(非 $A$)且(非 $B$)}'', 即从类型
\[
    ((A + B) \to \emptyt) \to (A \to \emptyt) \times (B \to \emptyt),
\]
给出一个居留元素.

\index{逻辑!经典的与构成主义的|(}
不过, 不能这样理解所有的经典\index{数学!经典的}重言式.
例如, 无法校验规则 \emph{``若非 ($A$ 且 $B$), 则(非 $A$) 或 (非 $B$)''}: 一般情况下, 无法构造下面这个对应类型的元素
\[ ((A \times B) \to \emptyt) \to (A \to \emptyt) + (B \to \emptyt).\]
反映的事实是, 在类型论中, 命题即类型的自然逻辑是\emph{构造主义的}.
这意味它不一定包括某些经典原理, 比如排中论 (\LEM{})\index{排中}和反证法, \index{证明!反证}以及依赖于它们的其它原理, 例如德摩根定律.
\index{定律!德摩根的|)}%
\index{德摩根定律|)}%

在哲学上被称为构成主义逻辑的原因是, 它自律于构造, 并贯彻计算意义上的\emph{有效性}.
不准确地说, 存在一个如何一步步地构造一个对象(和如何确定一个定理是否正确)的具体的算法\index{算法}.
所以需要忽略 \LEM{}, 因为这样就没有\emph{有效的}\index{有效的!步骤}步骤来判定一个命题是真还是假.

构成主义的类型论逻辑意味着, 它具备计算意义上的本质, 这正是计算机学家所感兴趣的.
这也意味类型论提供了\emph{公理自由度}.
\index{公理自由度} 例如, 虽然默认的构成主义没有 \LEM{}, 逻辑仍然是完备的(参见 \cref{sec:intuitionism}).
因此, 类型论不\emph{否认} \LEM{}, 我们可以考虑把它作为假设添加, 然后按惯例运行并不受限制.
在这个方面, 类型论丰富了, 而不是限制了常规的数学实践.

建议不熟悉构成主义逻辑的读者尝试更多的示例, 以此来熟悉它.
参见 \cref{ex:tautologies,ex:not-not-lem} 中的一些建议. \index{逻辑!经典的与构成主义的|)}

\mentalpause

迄今为止仅讨论了命题逻辑. \index{量化}%
\index{量化!构成的}%
\index{量化!普遍的}%
\index{判断式!逻辑}%
\index{逻辑!判断式}%
现在来考虑\emph{断言}逻辑, 除了逻辑连词``且''和``或'' , 还有量词 ``存在'' 和``所有''.
这种情况下, 类型具有双重角色: 它既可以作为命题, 也可以作为常规意义的类型, 例如被量化的定义域.
类型族 $P : A \to \UU$ 表示一个在 $A$ 上的断言, 而赋值一个元素 $a : A$ 得到类型 $P(a)$, 相当于命题 $P$ 对于 $a$ 成立.
现在通过量词来扩展之前的转换方式:
\begin{center}
    \medskip
    \begin{tabular}{ll}
        \toprule
        自然语言                  & 类型论               \\
        \midrule
        对于所有 $x:A$, $P(x)$ 成立 & $\prd{x:A} P(x)$  \\
        存在 $x:A$ 有 $P(x)$     & $\sm{x:A}$ $P(x)$ \\
        \bottomrule
    \end{tabular}
    \medskip
\end{center}
和之前一样, 可以展示(构成主义的)断言逻辑重言式转换为被居留类型.
例如, \emph{如果对于所有 $x:A$, $P(x)$ 和 $Q(x)$ 有(对于所有 $x:A$, $P(x)$) 且(对于所有 $x:A$, $Q(x)$)}, 可以转换为
\[
    (\tprd{x:A} P(x) \times Q(x)) \to (\tprd{x:A} P(x)) \times (\tprd{x:A} Q(x)).
\]
一个非正式的证明如下:
\begin{quote}
    假设对于所有 $x$, 有 $P(x)$ 和 $Q(x)$.
    第一步, 假设给定 $x$ 和证明 $P(x)$.
    通过假设, 有 $P(x)$ 和 $Q(x)$, 因此有 $P(x)$.
    第二步, 假设给定 $x$ 和证明 $Q(x)$.
    同样通过假设, 有 $P(x)$ 和 $Q(x)$, 因此有 $Q(x)$.
\end{quote}
第一步的句子通过引入其猜想的见证, 把蕴含定义为一个函数: \index{猜想}
\[
    f(p) \defeq \;\Box\; : (\tprd{x:A} P(x)) \times (\tprd{x:A} Q(x)).
\]
这里为了产生一个乘积类型的元素, 隐式地使用了序对的构造器, 在例子中就是使用单词``第一步''和``第二步'':
\[
    f(p) \defeq \Big( \;\Box\; : \tprd{x:A} P(x) \;,\; \Box\; : \tprd{x:A}Q(x) \;\Big).
\]
短语 ``假设给定 $x$ 和证明 $P(x)$'' 现在表示为以通常的方式定义\emph{依赖}函数, 即引入它输入的变量 \index{变量}%
因为它位于序对的构造器中, 通常把它些为 $\lambda$-抽象\index{lambda 抽象@$\lambda$-抽象}:
\[
    f(p) \defeq \Big( \; \lam{x} \;\big(\Box\; : P(x)\big) \;,\; \Box\; : \tprd{x:A}Q(x) \;\Big).
\]
现在引用``有 $P(x)$ 和 $Q(x)$''这个猜想, 得到 $p(x) : P(x)\times Q(x)$, 而 ``因此有$P(x)$'' 隐式地调用了投影:
\[
    f(p) \defeq \Big( \; \lam{x} \proj1(p(x)) \;,\; \Box\; : \tprd{x:A}Q(x) \;\Big).
\]
显而易见, 第二步的两个句子可以填充另一个空洞:
\[
    f(p) \defeq \Big( \; \lam{x} \proj1(p(x)) \;,\; \lam{x} \proj2(p(x)) \; \Big).
\]
当然, 作为示例的自然语言的证明比数学家在实践中使用的证明更加冗长;
它更像``证明导论''课里面使用的那种语言.
实际上数学家已经学会了填补空白, 所以实践中可以省略很多细节.
不过, 证明的有效性的标准还是是否能将证明转换为对应元素的构造.

\symlabel{leq-nat}%
一个更加实用的例子, 如何定义自然数的不等式.
一个自然的定义是, 若存在 $k:\nat$ 使得 $n+k=m$, 则 $n\le m$.
(这里又使用到了等同类型, 而会在下一节介绍它, 但是不需要特别了解它.)
在命题即类型的转换上, 可以给出:
\[
    (n\le m) \defeq \sm{k:\nat} (\id{n+k}{m}).
\]
请读者从这个定义证明这个熟悉的 $\le$ 的特性.
对于严格不等式, 有几种自然的选择, 比如说
\[
    (n<m) \defeq \sm{k:\nat} (\id{n+\suc(k)}{m})
\]
和
\[
    (n<m) \defeq (n\le m) \times \neg(\id{n}{m}).
\]
前者在构造主义数学中更自然, 其实在这种情况下两者是等价的, 因为 $\nat$ 具有 ``可判定的等同'' (参见 \cref{sec:intuitionism,prop:nat-is-set}).
\index{可判定的!等同}%

还可以这样理解类型 $\sm{x:A} P(x)$.
因为它的一个居留元是， 一个元素 $x:A$ 与一个 $P(x)$ 成立的见证, 而不是把 $\sm{x:A} P(x)$ 当作命题 ``存在 $x:A$ 使得 $P(x)$'', 可以把它视为``所有满足 $P(x)$ 的元素 $x:A$ 的类型'', 例如作为 $A$ 的``子类型''.
\index{子类型}%

会在 \cref{subsec:prop-subsets} 给出子类型的解释.
现在注意到到, 它允许我们把公理纳入类型定义, 作为在 \cref{sec:sigma-types} 讨论的数学结构.
例如, 要定义一个\define{半群}\index{半群}, 即一个类型 $A$ 与一个二元操作符 $m:A\to A\to A$ (即, 原群\index{原群}), 而且对于所有 $x,y,z:A$ 有 $m(x,m(y,z)) = m(m(x,y),z)$.
第二被命题可以被表示为 \[\prd{x,y,z:A} m(x,m(y,z)) = m(m(x,y),z),\]
所以半群的类型是 \[ \semigroup \defeq \sm{A:\UU}{m:A\to A\to A} \prd{x,y,z:A} m(x,m(y,z)) = m(m(x,y),z), \]
也就是说 半群是 $\mathsf{Magma}$ 的子类型.
在 $\semigroup$ 的一个居留元上应用投影, 可以抽取载体 $A$, 操作符 $m$, 和一个公理的见证.
在 \cref{sec:equality-of-structures} 会回到这个例子.

注意, 借助类型论中的全集, 可以表示 ``高阶逻辑'' --- 即可以量化所有的命题或者断言.
例如, 可以把 \emph{对于所有性质 $P : A \to \UU$, 若 $P(a)$ 则 $P(b)$} 表现为
\[
    \prd{P : A \to \UU} P(a) \to P(b)
\]
其中 $A : \UU$ 而 $a,b : A$.
不过, \emph{先验的}, 这个命题的全集与原来的不同, 等级比量化前的命题更高;
也就是
\[
    \Parens{\prd{P : A \to \UU_i} P(a) \to P(b)} : \UU_{i+1}.
\]
在 \cref{subsec:prop-subsets} 会回到这个问题.

\mentalpause

我们描述了``关于证明的'' 的\index{数学!关于证明的}%
命题的转换, 其中这些逻辑析取与构成语句的证明携带着一些信息.
例如, 如果有一个 $A+B$ 的居留元, 被当作一个 ``$A$ 或 $B$'' 的见证, 那么可以知道它来自 $A$ 或者 $B$.
类似的, 如果有 $\sm{x:A} P(x)$  的居留元, 被当作一个 ``存在一个 $x:A$ 满足 $P(x)$'' 的见证, 那么可以知道元素 $x$ (通过给定居留元元的第一投影).

作为逻辑性质相关证明的结果, 可以有``$A$ 当且仅当 $B$'' (回想 $(A\to B)\times (B\to A)$), 不过 $A$ 和 $B$ 表现的行为不同.
例如, 容易校验 ``$\mathbb{N}$ 当且仅当 $\unit$'', 而显然 $\mathbb{N}$和 $\unit$ 有重要不同.
陈述句 ``$\mathbb{N}$ 当且仅当 $\unit$'' 类型 $\mathbb{N}$ 说明\emph{作为一个纯命题时}, 才能表现为同样是命题的 $\unit$ (真命题).
有时把 ``$A$ 当且仅当 $B$'' 表示为 $A$ 和 $B$ 是\define{逻辑的等价}的.
\indexdef{逻辑等价}%
\indexdef{等价!逻辑}%
它有别于在 \cref{sec:basics-equivalences,cha:equivalences} 中引入的更强概念, 即\emph{类型的等价}: 尽管 $\mathbb{N}$ 和 $\unit$ 是逻辑等价的, 但是它们不是等价的类型.

在\cref{cha:logic} 会引入一种叫做 ``纯命题'' 的类型, 它们的类型等价和逻辑等价一致.
使用这些类型, 会对上面的逻辑进行适当修改,  丢弃包含在析取和构造中的附加信息.

最后注意, 可以把命题即类型反过来, 把任意类型 $A$ 当作一个命题, 而展示 $A$ 的居留元来证明这一点.
有时这个命题被陈述为 ``$A$ 是\define{被居留的}''.
\indexdef{被居留类型}%
\indexsee{类型!被居留}{被居留类型}%
也就是, 当讨论 $A$ 被居留时, 意味需要给定一个(特定的) $A$ 的元素, 但是不需要给这个元素取一个名字.
类似地, 为了表示 $A$ 是\emph{不被居留的}, 等同于给定一个 $\neg A$ 的元素.
特殊地, 空类型 $\emptyt$ 显然没有居留元, 因为 $\neg \emptyt \jdeq (\emptyt \to \emptyt)$ 的居留元是 $\idfunc[\emptyt]$.
\footnote{这和类型论是一致的陈述没有矛盾, 因为\emph{元理论}主张无法通过遵循类型论的规则来获得 $\emptyt$.\indexfoot{consistency}}

\index{证明|)}%
\index{命题!作为命题|)}%
\index{逻辑!命题即类型|)}%