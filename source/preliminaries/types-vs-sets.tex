\label{sec:axioms}

\index{类型论}
同伦类型论是数学基础语言, 即策梅洛-弗兰克尔\index{集合论!策梅洛-弗兰克尔}集合论的竞争对手. 不过, 它和集合论在一些重要方面有一些区别, 这得一些时间来适应. 为了仔细解释这些区别, 本书的剩余部分需要更加正式. 如导论中所述, 我们的目的是\emph{非形式地}描述类型论; 但是对于习惯集合论的数学家来说, 保持缜密可以避免一些常见的误解和错误.

我们注意到集合论的基础有两个 ``层次'': 一阶逻辑``\index{一阶!逻辑}的演绎系统, 和一阶逻辑所阐述的特定的公理, 比如 ZFC. 因此, 集合论不仅仅和集合有关, 而且与集合 (第二层代表的对象) 和命题 (第一层代表的对象) 的相互作用有关.

相比之下, 类型论是它自己的演绎系统: 它不需要通过任何上层结构来阐述, 比如一阶逻辑. 集合论基于两个基本概念, 集合和命题, 而类型论只有一个基本概念: \emph{类型}. 命题 (可以被证明, 证伪, 假设, 否定等的陈述句\footnote{令人困惑的, 令人困惑的, ``命题''与``定理''普遍被同义使用(可以追溯到欧几里得). 我们局限于逻辑学家的用法, 根据这种用法, \emph{命题}是\emph{可以}被证明的陈述句, 而\emph{定理}\indexfoot{定理} (或者``引理''\indexfoot{引理}和``推论''\indexfoot{推论})是一个\emph{已经被}证明的陈述句. 因此 ``$0=1$'' 和它的否定 ``$\neg(0=1)$'' 都是命题, 但只有后者才是定理.}) 被认为是特定的类型, 对应关系参见\pageref{tab:pov}页 \cref{tab:pov}. 因此, 数学上的\emph{证明一个定理}恒等于\emph{构造一个对象}的特殊情况 --- 这个情况下, 类型的每个居留元代表一个命题.

\index{演绎系统}%
这就引出了类型论和集合论之间的另一个区别, 为了解释它, 必须先简单说一下普通的演绎系统. 非形式地说, 演绎系统是\define{规则}\indexdef{规则}的汇总,%
这些规则可以推导出\define{判断}. \indexdef{判断}%
如果我们认为演绎系统是一个棋类游戏, \index{游戏!演绎系统看作}%
那么判断是遵循游戏规则可以到达的位置``位置''. 这种情况下, 判断就是元素 (就像群的元素), 而演绎规则就是运算 (就像群的乘法). 从逻辑的角度来看, 判断可以被认为是元理论的``外部的''陈述, 而不是理论本身的``内部的''陈述.

在一阶逻辑的演绎系统中(集合论的基础), 只能给出一种判断: 给定命题有证明. 也就是说, 每个命题 $A$ 可以引出一个判断 ``$A$ 有一个证明'', 而且所有判断都是这个形式. 比如说一阶逻辑规则, ``从 $A$ 和 $B$ 推断 $A\wedge B$'' 实际上是``证明构造'' 的规则, 即给定判断 ``$A$ 有证明'' 和 ``$B$ 有证明'', 可以演绎 ``$A\wedge B$ 有证明''. 注意判断 ``$A$ 有证明'' 与\emph{命题} $A$ 本身不在一个层次, 后者是理论的内部陈述. % In particular, we cannot manipulate it to construct propositions such as ``if $A$ has a proof, then $B$ does not have a proof''---unless we are using our set-theoretic foundation as a meta-theory with which to talk about some other axiomatic system.


类型论的基本判断, 比如 ``$A$ 有证明'', 写作 ``$a:A$'', 读作 ``项 $a$ 的类型是 $A$'', 或者更松散 ``$a$是类型 $A$ 的一个元素'' (或者在同伦类型论中, ``$a$ 是 $A$ 的一个点''). \indexdef{项}%
\indexdef{元素}%
\indexdef{点!类型的}%
当 $A$ 是一个代表命题的类型, 那么 $a$ 可以被称为 $A$ 的可证明性\emph{见证}\index{见证!命题正确性的}, 或者是 $A$ 的真实性的\emph{证据}\index{证据, 命题正确性的} (甚至是 $A$ 的\emph{证明}\index{证明}, 但我们将尽力避免使用这种令人困惑的术语). 这个情况下, 当一阶逻辑中类似的判断 ``$A$ 有一个证明'' 可推导时, (对于一些 $a$)类型论中判断 $a:A$ 也是可推导的(我们将在整本书中讨论被假设的公理和数学编码).

另一方面, 如果类型 $A$ 比起命题更像集合 (尽管如我们所见, 区别会变得模糊), 那么 ``$a:A$'' 可以被视为是集合论中的声明 ``$a\in A$''. 不过, 有一个必要的区别: ``$a:A$'' 是一个\emph{判断}而 ``$a\in A$'' 是一个\emph{命题}. 特别的, 在类型论中, 无法陈述 ``若 $a:A$ 则没有 $b:B$'', 也不能``证伪''判断 ``$a:A$''.

在集合论中, ``成员关系''是讨论两个已经存在的对象`` $a$ ''和`` $A$ ''可能有, 或者没有的关系, 而在类型论中, 我们无法单独讨论孤立的元素``$a$'': 所有元素\emph{就其本质而言}都是某个类型的元素, 而它的类型(一般而言)是唯一确定的. 因此, 当非正式地说``令 $x$ 为一个自然数'', 在集合论中是``令 $x$ 为一个元素, 而且假设 $x\in\nat$'' 的简写, 而在类型论中, ``令 $x:\nat$'' 是一个原子语句: 不能讨论一个变量, 但是没有指定它的类型.\index{成员关系}


乍一看来, 这好像是个令人不舒服的限制, 但是这样更接近直觉主义数学上的``令 $x$ 为一个自然数''的含义. 在实践中, 每当实际\emph{需要} ``$a\in A$'' 作为命题而不是判断时, 可以通过构造一个辅助的集合 $B$, 其中 $a$ 是它的元素, 而 $A$ 是一个子集. 这也很容易在类型论中表示, 通过把 $a$ 作为类型 $B$ 的一个元素, 而让 $A$ 作为 $B$ 上的断言;  参见\cref{subsec:prop-subsets}.

最后一个关于类型论和集合论的区别是如何对待等同关系. 数学中令人熟悉的等同关系的概念是一个命题:  例如我们能证否一个等同关系或者提出一个等同关系的猜想. 因为类型论中, 命题就是类型, 意味着等同关系是一个类型: 对于元素 $a,b:A$ (代表 $a:A$ 和 $b:A$) 我们有类型 ``$\id[A]ab$''. (在\emph{同伦}类型论, 等同关系命题的表现是令人陌生的: 参见 \cref{sec:identity-types,cha:basics}, 和本书剩余的部分当 $\id[A]ab$ 被居留, 那么 $a$ 和 $b$ 是\define{(命题)等同的}. \index{命题的!等同}%
\index{等同!命题的}%

然而, 在类型论中也需要一个等同\emph{判断}, 它的层次和判断 ``$x:A$''.\index{判断}相同.\index{判断}\symlabel{defn:judgmental-equality}%
它被称为\define{判断等同} \indexdef{等同!判断}%
\indexdef{判断等同}%
或\define{定义等同}, \indexdef{等同!定义的}%
\indexsee{定义等同}{等同, 定义的}%
而写作 $a\jdeq b : A$ 或简写为 $a \jdeq b$. 可以把它理解成 ``按定义是等同的''. 例如, 如果我们通过函数等式 $f(x)=x^2$ 定义函数 $f:\nat\to\nat$, 那么表达式 $f(3)$ 和 $3^2$ 是\emph{按定义}等同的. 在这个理论中, 按照定义等进行否定或者假设是没有意义的; 不能说``如果 $x$ 和 $y$ 是定义等同的, 那么 $z$ 和 $w$ 不是定义等同的''. 不管两个表达式是否是按定义等同的, 这仅仅是定义扩展的问题; 特别的, 这些都是算法\index{算法}可判定的的问题(尽管算法是元理论的, 而不是理论内部的).\index{可判定的!定义等同}

随着类型论变得更加复杂, 判断等同会变得更加微妙, 但是这是好的直觉. 另外, 如果演绎系统看作一个代数理论, 那么判断等同就是这个理论中的等同关系, 类似与群中的元素的等同关系 --- 只是这里有一个令人困惑的地方, 类型论的演绎系统\emph{还}\emph{存在}一个对象(也就是类型``$a=b$''), 也能表示``等同关系''.

之所以\emph{想要}一个等同判断的概念, 是因为它可以从其它判断 (如 ``$a:A$'') 来构造. 假设已经给定了一个证明 $3^2=9$, 比如给定 $p$ 的判断 $p:(3^2=9)$. 那么 $p$ 也是 $f(3)=9$ 的证明, 因为\emph{根据定义}, $f(3)$ 就是 $3^2$. 解释这条规则的最好方法就是: 给出判断 $a:A$ 和 $A\jdeq B$, 可以派生判断 $a:B$.

因此对我们来说, 类型论将是基于两种判断的演绎系统: \begin{center}
                               \medskip
                               \begin{tabular}{cl}
                                   \toprule
                                   判断 &含义\\
                                   \midrule
                                   $a : A$ &``$a$ 是一个类型为 $A$  的对象''\\
                                   $a \jdeq b : A$ &``$a$ 和 $b$ 是类型为 $A$ 按照定义等同的对象.''\\
                                   \bottomrule
                               \end{tabular}
                               \medskip
\end{center}
%
\symlabel{defn:defeq}%
引用定义等同时, 例如, 为了定义一个事物, 而它与另一个事物相同, 可以使用符号``$\defeq$''. 于是, 之前定义的函数 $f$ 可以写作 $f(x)\defeq x^2$.

因为判断无法合并成更加复杂的语句, 所以符号 ``$:$'' 和符号 ``$\jdeq$'' 的优先级最低. \footnote{在形式\indexfoot{数学!形式}类型论中, 逗号和 $\vdash$ 符号的优先级更加低.%
如, $x:A,y:B\vdash c:C$ 被解析成 $((x:A),(y:B))\vdash (c:C)$. 不过, 我们避免这种记号直到 \cref{cha:rules}.} 因此, 例如, ``$p:\id{x}{y}$'' 应该被解析成 ``$p:(\id{x}{y})$'', 因为 ``$\id{x}{y}$'' 是一个类型, 而不是``$\id{(p:x)}{y}$'', 因为 ``$p:x$'' 是一个判断, 它无法等同于其它任何事物. 类似的, ``$A\jdeq \id{x}{y}$'' 只能被解析成 ``$A\jdeq(\id{x}{y})$'',  尽管在这种极端情况下, 应该加上圆括号便于理解. 此外, 还有常用的链式等于符号 --- 例如 $a=b=c=d$ 意味着 ``$a=b$ 且 $b=c$ 且 $c=d$, 因此 $a=d$'' --- 判断等同也是这样. 通常上下文足以让人明白意图.

这里大概是提及这个常用的数学符号的时机, ``$f:A\to B$'', 表示 $f$ 是一个从  $A$ 到 $B$ 的函数, 可以看作是一个类型判断, 因为我们用符号  ``$A\to B$'' 来表示从  $A$ 到 $B$ 的函数类型 (这是类型论中的标准用法; 参见 \cref{sec:pi-types}).

\index{假设|(defstyle}%
判断的构造可以依赖于 $x:A$ 形式的\emph{假设}, 其中 $x$ 是一个 \indexdef{变量}%
而 $A$ 是一个类型. 例如, 基于假设 $m,n : \nat$, 可以构造对象 $m + n : \nat$. 另一个例子是, 假设 $A$ 是一个类型, $x,y : A$, 而  $p : \id[A]{x}{y}$, 可以构造一个元素 $p^{-1} : \id[A]{y}{x}$. 类似的假设的汇集被称为\define{上下文};\index{上下文}
按照拓扑学的角度, 它可以被称为 ``参数\index{参数!空间}空间''. 事实上, 上下文必须是关于假设的有序列表, 因为后面的假设可能依赖前面的假设: 假设 $x:A$ 必须\emph{晚于}类型 $A$ 作为变量所出现的假设.

如果假设 $x:A$ 中的类型 $A$ 代表一个命题, 那么这个假设是类型论中的\emph{猜想}: \indexdef{猜想}%
命题 $A$ 成立. 当类型被当作命题, 我们可以忽略证明的名称. 因此, 在上面的第二个例子中, 可以改为, 假设 $\id[A]{x}{y}$, 我们可以证明 $\id[A]{y}{x}$. 不过, 因为我们做的是 ``证明相关'' 的数学, \index{数学!证明相关}%
我们通常会把证明称为对象. 在上面的例子中, 譬如, 我们可能想要建立 $p^{-1}$ 传递性和自反性的证明, 就像广群一样; 参见\cref{cha:basics}.

注意在词语\emph{假设}的含义下, 可以假设命题等同 (通过假设一个变量 $p:x=y$), 但是不能假设一个判断等同 $x\jdeq y$, 因为它不是一个类型, 它没有元素. 不过, 可以做一些其它事情, 看起来像是假设命题等同的: 如果有个一类型或者一个元素, 它是一个变量 $x:A$, 那么可以用任何特定的元素 $a:A$ \emph{替换} $x$, 来获得更加特殊的类型或者元素. 我们会使用一些语言, 比如``假设 $x\jdeq a$'' 来指代这种替换, 虽然在上面介绍的意义上, 它不是一个\emph{假设}.\index{假设|)}\index{假设|)}%

出于同样的原因, 无法\emph{证明}两个判断之间相等, 因为它不是一个可以构造出见证的类型. 不过, 我们有时会把判断等同作为定义的一部分, 例如``存在 $f:A\to B$ 使得 $f(x)\jdeq y$''. 这应该被视为是两个单独的判断: 首先我们关于元素 $f$ 做出判断  $f:A\to B$, 然后我们做出额外的判断 $f(x)\jdeq y$.

在本章剩下的内容中, 会非形式地介绍类型论, 而对本书而言这已足够; 更形式的记录在\cref{cha:rules}. 除了相当明显的规则 (比如说判断等同的事物可以互相被替换\index{替换}), 这些规则可以被归类为为\emph{类型形成器}. 每个类型形成器包含了构造类型的方法 (可能会使用先前构造出来的类型), 以及构造规则, 还有这个类型的元素的行为. 在绝大部分情况下, 这些规则伴随相当可循的模式, 不过这里没有严密的尝试; 具体参见 \cref{sec:finite-product-types} 和 \cref{cha:induction}.\index{类型论!非正式的}


\index{公理!与规则}%
\index{规则!与公理}%
本章介绍的类型论中, 有一个重点, 就是它只有\emph{规则}, 而没有任何\emph{公理}. 用判断描述演绎系统时, \emph{规则}可以根据其它判断的汇集, 得到一个判断, 而\emph{公理}就是一开始给出的判断. 把演绎系统看成一个棋类游戏, 那么规则就是游戏规则, 而公理就是初始点位. 把演绎系统当作代数理论, 那么规则就是操作符, 而公理就是特定的\emph{生成器}.

在集合论中, 唯一的规则就是一阶逻辑的规则 (比如, 这些规则允许根据``$A$ 有证明'' 和 ``$B$ 有证明'' 推断 ``$A\wedge B$ 有证明''): 所有关于集合的行为的信息都包含在公理中. 相比之下, 在类型论中, 通常这些信息都存在\emph{规则}中, 无需公理. 比如, 在\cref{sec:finite-product-types}我们会看到一些规则, 允许我们根据 ``$a:A$'' 和 ``$b:B$'', 演绎出判断 ``$(a,b):A\times B$'', 而在集合论中, 类似的陈述应该是对偶公理 (的结果).

类型论只使用规则的好处是, 规则是``程序性的''. 特别的, 这使类型理论的良好计算特性为了可能 (尽管不是确保), 比如说``正规性''.\index{正规性} 不过, 在传统类型理论使用这种风格, 还没有明白如何形式化所有东西, 所以需要\emph{同伦}类型论. 特别的, 在\cref{sec:compute-pi,sec:compute-universe,cha:hits} 中提出的关于类型论的规则, 不得不允许它添加额外的公理, 也就是\emph{一价公理}. 不过在本章, 我们局限于传统的, 只使用规则的类型论.