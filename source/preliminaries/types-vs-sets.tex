\label{sec:axioms}

\index{类型论}
同伦类型论是数学基础语言(之一), 是策梅洛-弗兰克尔\index{集合论!策梅洛-弗兰克尔}集合论的替代.
不过, 在一些重要方面, 它有别于集合论, 而这需要一些时间来适应.
这里比本书的剩余部分更加形式, 来仔细解释这些区别.
正如导论所述, 我们的目的是\emph{非形式地}描述类型论;
但是对于习惯集合论的数学家来说, 在开始部分保持缜密, 可以避免一些常见的误解和错误.

注意集合论的基础有两个 ``层次'': 一阶逻辑\index{一阶!逻辑}的演绎系统, 和系统中用公式表示的, 特定理论的的公理, 例如 ZFC.
因此, 集合论不仅与集合有关, 而且与集合 (第二个层次代表的对象) 和命题 (第一个层次代表的对象) 之间的相互作用有关.

相比之下, 类型论是它自己的演绎系统: 它不需要在任何上层结构中用公式表示, 例如一阶逻辑.
集合论基于两个基本概念, 集合和命题, 而类型论只有一个基本概念: \emph{类型}.
命题 (可以被证明, 证伪, 假设, 否定等的语句%
\footnote{令人困惑的是``命题''与``定理''普遍被同义使用(可以追溯到欧几里得).
我们会局限于逻辑学家的用法, 根据这种用法, \emph{命题}是\emph{可以}被证明的语句, 而\emph{定理}
\indexfoot{定理}%
(或者``引理''\indexfoot{引理}和``推论''\indexfoot{推论})
是一个\emph{已经被}证明的语句.
因此 ``$0=1$'' 和它的否定 ``$\neg(0=1)$'' 都是命题, 但只有后者才是定理.})
被认为是特定的类型, 对应关系参见\pageref{tab:pov}页\cref{tab:pov}.
因此, 数学上的\emph{``证明一个定理''}恒等于\emph{``构造一个对象''}的特殊情况 --- 构造代表命题的类型的居留元.

\index{演绎系统}%
这就引出了类型论和集合论之间的另一个区别, 为了解释它, 必须先简单说一下普通的演绎系统.
非形式地说, 演绎系统是\define{规则}\indexdef{规则}的汇总,%
这些规则可以推导出\define{判断}. \indexdef{判断}%
如果认为演绎系统是一个棋类游戏, \index{游戏!演绎系统看作}%
那么判断是遵循游戏规则可以到达的位置``位置''.
也可以认为演绎系统是一种代数理论, 这种情况下, 判断就是元素 (就像群的元素), 而演绎规则就是运算 (就像群的乘法).
从逻辑的角度来看,  判断是``外部的''语句, 在元理论中, 而不是理论自身``内部的''语句.

在(集合论基于的)一阶逻辑的演绎系统中, 只能给出一种判断: 给定命题有证明.
也就是说, 每个命题 $A$ 可以引出一个判断 ``$A$ 有一个证明'', 而且所有判断都是这个形式.
比如说一阶逻辑规则, ``从 $A$ 和 $B$ 推断 $A\wedge B$'' 实际上是``构造证明'' 的规则, 即给定判断 ``$A$ 有证明'' 和 ``$B$ 有证明'', 可以演绎出 ``$A\wedge B$ 有证明''.
注意判断 ``$A$ 有证明'' 与\emph{命题} $A$ 本身不在一个等级, 后者是理论的内部语句.
% In particular, we cannot manipulate it to construct propositions such as ``if $A$ has a proof, then $B$ does not have a proof''---unless we are using our set-theoretic foundation as a meta-theory with which to talk about some other axiomatic system.

类型论的基本判断, 比如 ``$A$ 有证明'', 写作 ``$a:A$'', 读作 ``项 $a$ 的类型是 $A$'', 或者更松散的 ``$a$ 是类型 $A$ 的一个元素'' (或者在同伦类型论中, ``$a$ 是 $A$ 的一个点'').
\indexdef{项}%
\indexdef{元素}%
\indexdef{点!类型的}%
当 $A$ 是一个代表命题的类型, 那么 $a$ 可以被称为 $A$ 的可证明性\emph{见证}\index{见证!命题正确性的}, 或者是 $A$ 的真实性的\emph{证据}\index{证据, 命题正确性的}
(甚至是 $A$ 的\emph{证明}\index{证明}, 但我们会尝试避免使用这种不清楚的术语).
这种情况下, 当一阶逻辑中类似的判断 ``$A$ 有一个证明'' 可推导时, 类型论中判断 $a:A$ (对于一些 $a$)恰好也是可推导的(我们会在整本书中讨论, 被假设的公理和数学编码中的差异).

另一方面, 如果类型 $A$ 比起命题更像集合 (尽管正如所见, 区别会变得模糊), 那么 ``$a:A$'' 可以视为是集合论中的语句 ``$a\in A$''.
不过有一个必要的区别: ``$a:A$'' 是一个\emph{判断}而 ``$a\in A$'' 是一个\emph{命题}.
特别地, 在类型论内部, 无法陈述这样的语句 ``若 $a:A$ 则没有 $b:B$'', 也不能``证伪''判断 ``$a:A$''.

理解它的一个好方法是, 集合论中, ``成员关系''是讨论两个已经存在的对象`` $a$ ''和`` $A$ ''可能有, 或者没有的关系, 而类型论中, 无法单独讨论孤立的元素``$a$'': 所有元素\emph{就其本质而言}都是某个类型的元素, 而它的类型(一般而言)是唯一确定的.
因此, 当非形式地说``令 $x$ 为一个自然数'', 在集合论中是``令 $x$ 为一个元素, 而且假设 $x\in\nat$'' 的简写, 而在类型论中, ``令 $x:\nat$'' 是一个原子语句: 没有指定变量的类型, 就不能讨论它.
\index{成员关系}%

乍一看来, 这个限制令人不舒服, 但可以认为这更接近直觉主义数学上``令 $x$ 为一个自然数''的含义.
实践中, 每当确实\emph{需要} ``$a\in A$'' 作为命题而不是判断时, 总有辅助集合 $B$, 其中 $a$ 是它的元素, 而 $A$ 是它的子集.
在类型论中, 这种情况也很容易表示, 通过把 $a$ 作为类型 $B$ 的一个元素, 而让 $A$ 作为 $B$ 上的断言;
参见\cref{subsec:prop-subsets}.

最后一个关于类型论和集合论的区别是如何对待等同.
数学中, 常见的等同的概念是一个命题: 例如可以证否一个等同或者提出假定等同为猜想.
因为类型论中, 命题即类型, 意味着等同是一个类型: 对于元素 $a,b:A$ (代表 $a:A$ 和 $b:A$) 有类型 ``$\id[A]ab$''.
(在\emph{同伦}类型论, 当然, 等同命题具有陌生的行为: 参见 \cref{sec:identity-types,cha:basics}, 以及本书剩余的部分).
当 $\id[A]ab$ 被居留, 那么 $a$ 和 $b$ \define{(命题地)相等}.
\index{命题地!等同}%
\index{等同!命题地}%

然而, 在类型论中也需要一个等同\emph{判断}, 它的等级和判断 ``$x:A$''\index{判断}等同.
\index{判断}%
\symlabel{defn:judgmental-equality}%
它被称为\define{判断等同}%
\indexdef{等同!判断}%
\indexdef{判断等同}%
或\define{定义等同},
\indexdef{等同!定义}%
\indexsee{定义等同}{等同, 定义}%
而写作 $a\jdeq b : A$ 或简写为 $a \jdeq b$.
可以把它理解成 ``按定义相等''.
例如, 如果用等式 $f(x)=x^2$ 定义函数 $f:\nat\to\nat$, 那么表达式 $f(3)$ \emph{按定义}等同于 $3^2$.
这个理论中, 否定或者假设按定义等同是没有意义的;
不能说``如果 $x$ 按定义等同于 $y$, 那么 $z$ 按定义不等同于 $w$''.
不管两个表达式是否是按定义等同的, 这仅仅是定义扩展的问题;
特别的, 这些都是算法\index{算法}可判定的的问题(尽管算法是元理论的, 而不是理论内部的).
\index{可判定的!定义等同}%

随着类型论变得更加复杂, 判断等同会变得更加微妙, 但是这个直觉是好的.
另外, 如果把演绎系统看作一个代数理论, 那么判断等同就仅是这个理论中的等同, 类似与群中的元素的等同 ---
只是这里有一个令人困惑的地方, 类型论的演绎系统\emph{内}\emph{还}有一个对象(也就是类型``$a=b$''), 在内部表示``等同''的概念.

之所以\emph{想要}一个判断等同的概念, 是因为它可以从其它判断 (如 ``$a:A$'') 来构造.
假设已经给定了一个证明 $3^2=9$, 比如给定 $p$ 的判断 $p:(3^2=9)$.
那么该见证 $p$ 也是 $f(3)=9$ 的证明, 因为\emph{根据定义}, $f(3)$ 就是 $3^2$.
解释这条规则的最好方法就是: 给出判断 $a:A$ 和 $A\jdeq B$, 可以推导判断 $a:B$.

因此对我们来说, 类型论将是基于两种形式的判断的演绎系统:
\begin{center}
    \medskip
    \begin{tabular}{cl}
        \toprule
        判断              & 含义                                \\
        \midrule
        $a : A$         & ``$a$ 是类型 $A$ 的一个对象''             \\
        $a \jdeq b : A$ & ``$a$ 和 $b$ 是类型 $A$ 的对象, 并在定义地相等.'' \\
        \bottomrule
    \end{tabular}
    \medskip
\end{center}%
\symlabel{defn:defeq}%
引入定义等同时, 例如, 为了定义等同于其它事物的事物, 可以使用符号``$\defeq$''.
于是, 之前定义的函数 $f$ 可以写作 $f(x)\defeq x^2$.

因为判断无法相互合并成更加复杂的语句, 所以符号 ``$:$'' 和符号 ``$\jdeq$'' 的优先级最低.
\footnote{在形式化的\indexfoot{数学!形式化的}类型论中, 逗号和 $\vdash$ 符号的优先级更加低.
例如, $x:A,y:B\vdash c:C$ 被解析成 $((x:A),(y:B))\vdash (c:C)$.
不过, 这本书避免这种记号直到 \cref{cha:rules}.}
于是, 例如, ``$p:\id{x}{y}$'' 应该被解析成 ``$p:(\id{x}{y})$'', 因为 ``$\id{x}{y}$'' 是一个类型, 而不是``$\id{(p:x)}{y}$'', 因为 ``$p:x$'' 是一个判断, 它无法等同于其它任何事物.
类似的, ``$A\jdeq \id{x}{y}$'' 只能被解析成 ``$A\jdeq(\id{x}{y})$'', 尽管在这种极端情况下, 应该加上圆括号便于理解.
此外, 还有常用的链式等同符号 --- 例如 $a=b=c=d$ 意味着 ``$a=b$ 且 $b=c$ 且 $c=d$, 因此 $a=d$'' --- 判断等同也是这样.
语境通常足以让人明白意图.

这里大概是提及这个常用的数学符号的时机, ``$f:A\to B$'', 表示 $f$ 是一个从 $A$ 到 $B$ 的函数, 可以看作是一个类型判断, 因为用符号 ``$A\to B$'' 来表示从 $A$ 到 $B$ 的函数类型
(这是类型论中的标准用法;
参见 \cref{sec:pi-types}).

\index{假设|(defstyle}%
判断的构造可以依赖于形式 $x:A$ 的\emph{假设}, 其中 $x$ 是一个变量\indexdef{变量}而 $A$ 是一个类型.
例如, 基于假设 $m,n : \nat$, 可以构造对象 $m + n : \nat$.
另一个例子是, 假设 $A$ 是一个类型, $x,y : A$, 而  $p : \id[A]{x}{y}$, 可以构造一个元素 $p^{-1} : \id[A]{y}{x}$.
这种假设的汇总被称为\define{语境};\index{语境}
从拓扑学的角度看, 可以称之为 ``参数\index{参数!空间}空间''.
事实上, 严格地说语境必须是关于假设的有序列表, 因为后面的假设可能依赖前面的假设: 假设 $x:A$ 必须\emph{晚于}类型 $A$ 作为变量所出现的假设.

如果假设 $x:A$ 中的类型 $A$ 代表一个命题, 那么这个假设是类型论中的\emph{猜想}:
\indexdef{猜想}%
命题 $A$ 成立.
类型被视为命题时, 可以忽略证明的名称.
因此, 在上面的第二个例子, 可以改为, 假设 $\id[A]{x}{y}$, 可以证明 $\id[A]{y}{x}$.
不过, 因为做的是 ``关于证明的'' 数学,
\index{数学!关于证明的}%
通常会把证明称为对象.
上面的例子中中, 例如, 可能想要建立 $p^{-1}$ 传递性和自反性的证明, 就像群胚一样;
参见\cref{cha:basics}.

注意在词语\emph{假设}的含义下, 可以假设命题的等同 (通过假设一个变量 $p:x=y$), 但是不能假设判断等同 $x\jdeq y$, 因为它不是一个类型, 它没有元素.
不过, 可以做一些其它事情, 看起来像是假设一个命题的等同: 如果有个一类型或者一个元素, 涉及到变量 $x:A$, 那么可以用任何特定的元素 $a:A$ \emph{替换} $x$, 来获得更加特殊的类型或者元素.
我们会使用一些语言, 比如``假设 $x\jdeq a$'' 来指代这种替换, 虽然在上面介绍的意义上, 它不是一个\emph{假设}.
\index{假设|)}%
\index{假设|)}%

出于同样的原因, 无法\emph{证明}判断等同, 因为它不是类型, 且无法展示它的见证.
不过, 有时会把判断等同作为定理的一部分, 例如``存在 $f:A\to B$ 使得 $f(x)\jdeq y$''.
应该分别视其为两个判断: 首先关于元素 $f$ 做出判断  $f:A\to B$, 然后做出额外的判断 $f(x)\jdeq y$.

本章的剩余部分, 会非形式地介绍类型论, 而对本书而言这已足够;
更形式的记录在\cref{cha:rules}.
除了相当明显的规则 (比如说判断地相等的事物可以被彼此替换\index{替换}), 这些规则可以被归类为为\emph{类型形成器}.
每个类型形成器包含了构造类型的方法 (可能会使用先前构造出来的类型), 以及构造规则, 以及这个类型的元素的行为.
在绝大部分情况下, 这些规则伴随相当可循的模式, 不过这里遵守;
具体参见 \cref{sec:finite-product-types} 以及 \cref{cha:induction}.
\index{类型论!非形式的}%

\index{公理!与规则}%
\index{规则!与公理}%
本章介绍的类型论中, 有一个重点, 就是它只有\emph{规则}, 没有任何\emph{公理}.
用判断的术语描述演绎系统时, \emph{规则}可以根据其它判断的汇总, 得到一个判断, 而\emph{公理}就是一开始给出的判断.
把演绎系统看成一个棋类游戏, 那么规则就是游戏规则, 而公理就是初始点位.
把演绎系统当作代数理论, 那么规则就是操作符, 而公理就是这个理论中特定自由模型的\emph{生成器}.

在集合论中, 唯一的规则就是一阶逻辑的规则 (比如, 这些规则允许根据``$A$ 有证明'' 和 ``$B$ 有证明'' 推断 ``$A\wedge B$ 有证明''): 所有关于集合的行为的信息都包含在公理中.
相比之下, 在类型论中, 通常这些信息都存在\emph{规则}中, 无需公理.
比如, 在\cref{sec:finite-product-types}会看到一些规则, 允许根据 ``$a:A$'' 和 ``$b:B$'', 演绎出判断 ``$(a,b):A\times B$'', 而在集合论中, 类似的语句应该是对偶公理 (的结果).

类型论只使用规则的好处是, 规则是``程序性的''.
特别地, 这使类型理论的良好计算特性成为了可能(尽管不是自动的确保), 比如说``正规性''.
\index{正规性}%
不过, 在传统类型理论使用这种风格, 我们还不明白如何形式化所有东西, 所以需要\emph{同伦}类型论.
特别的, 本章提出的类型论, 在\cref{sec:compute-pi,sec:compute-universe,cha:hits}中, 不得不允许添加额外的公理, 尤其是\emph{一价公理}.
不过在本章, 将局限于传统的, 基于规则的类型论.