给定类型 $A,B:\UU$ 构造类型 $A\times B:\UU$, 我们称这个类型为\define{笛卡尔积}. \indexsee{笛卡尔积}{类型, 积}%
\indexsee{类型!笛卡尔积}{类型, 积}%
\index{类型!积|(defstyle}%
\indexsee{积!of types}{类型, 积}%
我们还介绍了无效类型, 它又被称为\define{单元类型} $\unit : \UU$. \indexsee{无效!积}{类型, 单元}%
\indexsee{单元!类型}{类型, 单元}%
\index{类型!单元|(defstyle}%
我们把 $A\times B$ 的元素写成对子 $\tup{a}{b} : A \times B$, 这里的 $a:A$ 而且 $b:B$, 而且类型 $\unit$ 唯一的元素是特殊对象 $\ttt : \unit$. \indexdef{对子!有序的}%
然而, 和集合论不同, 在集合论中, 有序对子是特殊的集合, 它组成了笛卡尔集, 而在类型论中, 有序对子是一个和函数一样的原始概念.  

\begin{rmk}\label{rmk:introducing-new-concepts}
类型论中有一种引入新类型的通用模式.
我们在之前的 \cref{sec:function-types,sec:pi-types}\footnote{之前对宇宙的描写是一个意外.} 已经见过了它.
为了指定一个类型, 我们需要指定:
\begin{enumerate}
\item 如何构造类型, 可以通过\define{形成规则(formation rules)}.
\indexdef{形成规则}%
\index{规则!形成}%  
(例如, 我们可以构造函数 $A \to B$, 这里的 $A$ 是一个类型, 而 $B$ 也是一个类型. 我们可以构造依赖函数类型 $\prd{x:A} B(x)$, 这里的 $A$ 是一个类型,  而 $B(x)$ 是一个来自于 $x:A$ 的类型.) 

\item 如何构造类型的元素. 
这被称为类型的\define{构造器}(constructors)或者\define{引入规则}(introduction rules). 
\indexdef{构造器}%
\indexdef{规则!引入}%
\indexdef{引入规则}%
(例如, 每个函数的构造器 $\lambda$-abstraction.
回想一下直接定义, 就像 $f(x)\defeq 2x$ 可以等效的表达
为 $\lambda$-abstraction $f\defeq \lam{x} 2x$.)

\item 如何使用这个类型的元素. 
这被称为\define{消除器}或者\define{消除规则}(elimination rules).
\indexsee{规则!消除}{消除器}%
\indexsee{消除规则}{消除器}%
\indexdef{消除器}%
(例如, 每个函数类型有一个消除器, 即函数的应用)

\item 
一个\define{计算规则}\indexdef{计算规则}\footnote{也被称为 \define{$\beta$-reduction}\index{beta-reduction@$\beta $-reduction|footstyle}}, 它表示了消除器如何作用于一个构造器.
(例如, 对于函数, 计算规则指出了 $(\lamu{x:A}\Phi)(a)$ 和把 $\Phi$ 中的 $x$ 替换为 $a$ 的结果是判断等同的.) 

\item 
一个非必要的\define{唯一性原理}\indexdef{唯一性!原理}\footnote{也被称为 \define{$\eta$-expansion}\index{eta-expansion@$\eta $-expansion|footstyle}}, 它表示了
以这个类型为值域或者到达域映射的唯一性.  对于某些类型, 唯一性原理是到这个类型的映射的特征, 这个特征说明了所有这个类型的元素的唯一性, 只取决于应用消除器到这个元素的结果, 而且它可以从应用一个构造器的结果中重构 --- 从而表达了构造函数如何作用于消除器, 与计算规则相对应.  (例如, 对于函数, 唯一性原理说明任何函数 $f$ 和``扩展''函数 $\lamu{x} f(x)$ 判断等同, 因为唯一性取决于它的结果)(An example is the coproduct type introduced in \cref{sec:coproduct-types}, whose uniqueness principle is mentioned in \cref{sec:universal-properties}.)  

当唯一性原理不作为判断等同的规则时, 它通常也可以作为\emph{命题}等同来从其它关于这个类型的规则来证明.
这个情况下我们称之为\define{命题唯一性原理}.
\indexdef{唯一性!原理, 命题的}%
\indexsee{命题的!唯一性原理}{唯一性原理, 命题的}%
(在后面的章节我们也偶尔会遇见\emph{命题唯一性原理}.)
\indexdef{计算规则!命题的}%
\end{enumerate}
规则推理在 \cref{sec:syntax-more-formally} 进行相应的组织和命名; 参见例子 \cref{sec:more-formal-pi}, 这里实现了每种可能性. \end{rmk}

构造对子的方法是很明显的: 给定 $a:A$ 和 $b:B$, 我们可以构造 $(a,b):A\times B$. 类似的, 唯一的构造 $\unit$ 的元素的方法是, $\ttt:\unit$. 我们认为 ``每个 A × B 的元素是一个对子'', 即乘积的唯一性原理; 我们不认为它是类型论的规则, 但是我们后面会用命题等同来证明它. 

现在的问题是我们如何\emph{使用}对子, 例如, 我们如何根据乘积类型来定义函数?让我们首先考虑非依赖函数的定义 $f : A\times B \to C$. 因为我们令 $A\times B$ 的元素只能是对子, 所以我们定义函数的方法是, 规定函数 $f$ 应用到对子 $\tup{a}{b}$ 的结果. 我们可以通过提供一个函数 $g : A \to B \to C$, 来规定它的结果. 因此, 我们引入一个新的规则 (乘积的消除规则), 即对于任何 $g$, 我们可以定义函数 $f : A\times B \to C$ 通过\ \[ f(\tup{a}{b}) \defeq g(a)(b). \]
我们这里避免写做 $g(a,b)$, 为了强调 $g$ 不是一个定义域是乘积类型的函数. (不过, 在本书之后, 我们经常会使用 $g(a,b)$, 不管定义域是乘积类型的函数还是两个变量柯里化以后的函数.) 这个定义等式是乘积类型的计算规则\index{计算规则!乘积类型的}. 

注意在集合论中, 我们可以通过所有 $A\times B$ 的元素都是有序对这个事实, 来解释上面的定义 $f$ 的合理性.所以通过这种对来定义 $f$ 的方式已经足够了. 与之相反的情况: 我们假设 $A\times B$是良好定义的就像我们令它的值只能是对子一样, 然后(或者更加缜密, 从下面更加通用的依赖函数的版本)我们可以\emph{证明} $A\times B$ 的每个元素都是对子. 从范畴论来看, 我们可以说我们定义了乘积 $A\times B$ 左伴随于 ``exponential'' $B\to C$, 正如我们之前介绍的. 

例如, 我们可以派生\define{投影}\indexsee{函数!投影}{投影}%
\indexsee{组成, 对子的}{投影}%
\indexdef{投影!从笛卡尔积类型}%
函数 \symlabel{defn:proj}%
\begin{align*}
\fst &: A \times B \to A \\
\snd &: A \times B \to B
\end{align*}
和定义等式  \begin{align*}
\fst(\tup{a}{b}) &\defeq a \\
\snd(\tup{a}{b}) &\defeq b.
\end{align*}
%
\symlabel{defn:recursor-times}%
比起每次定义函数时调用这个函数定义的原理, 一个替代方法是只在宇宙上执行一次, 然后可以在其它情况下应用得到的函数. 即我们可以定义一个函数类型 \begin{equation}
\rec{A\times B} : \prd{C:\UU}(A \to B \to C) \to A \times B \to C
\end{equation}
和这个定义等式 \[\rec{A\times B}(C,g,\tup{a}{b}) \defeq g(a)(b). \]
然后这样直接根据定义等式来定义函数 $\fst$ and $\snd$, 我们可以这样定义 \begin{align*}
\fst &\defeq \rec{A\times B}(A, \lam{a}{b} a)\\
\snd &\defeq \rec{A\times B}(B, \lam{a}{b} b).
\end{align*}
我们把函数 $\rec{A\times B}$ 称为乘积类型的\define{递归子}\indexsee{递归子}{递归原理}.%
 ``递归子''这个名字有一点不好, 因为这个地方没有递归. 这是因为乘积类型是归纳类型的通用框架的简化, 对于自然数这样的类型来说, 递归子确实是递归的. 我们也可以讨论笛卡尔积的\define{递归原理}, 意味我们可以通过给定它的值, 定义函数 $f:A\times B\to C$ 如上所述. \index{递归原理!笛卡尔积的}%

我们把它留作习题: 递归子可以从投影派生, 反之亦然. % Ex: Derive from projections


\symlabel{defn:recursor-unit}%
单元类型也有一个递归子: \[\rec{\unit} : \prd{C:\UU}C \to \unit \to C\]
和这个定义等式 \[ \rec{\unit}(C,c,\ttt) \defeq c. \]
尽管我们为了保持类型定义的模式仍然包含了$\unit$ , 但它在递归子中完全没有被使用, 因为我们可以忽略 $\unit$ 的参数直接定义这个函数. 

为了能够在乘积类型上定义\emph{依赖}函数, 我们必须一般化递归子. 给定 $C: A \times B \to \UU$, 我们可以定义函数 $f : \prd{x : A \times B} C(x)$ 通过提供一个函数 \narrowequation{
g : \prd{x:A}\prd{y:B} C(\tup{x}{y})
} 和定义等式 \[ f(\tup x y) \defeq g(x)(y). \] 
例如, 我们可以这样证明命题的唯一性原理, 也就是说每个 $A\times B$ 的元素, 都有一个对子和它是相等的. \index{唯一性!原理, 命题的!乘积类型的}%
具体地说, 我们可以构造一个函数 \[ \uniq{A\times B} : \prd{x:A \times B} (\id[A\times B]{\tup{\fst {(x)}}{\snd {(x)}}}{x}). \]
这里我们使用了恒等类型, 我们会在 \cref{sec:identity-types} 引入它. 不过, 我们现在只需要知道, 它有一个自反元素 $\refl{x} : \id[A]{x}{x}$ 对于任何 $x:A$. 给定它, 我们可以定义 \label{uniquenessproduct}
\[ \uniq{A\times B}(\tup{a}{b}) \defeq \refl{\tup{a}{b}}. \]
这个构造是有效的, 因为 $x \defeq \tup{a}{b}$ 的情况下, 我们可以使用自反的定义等式, 计算  \[ \tup{\fst(\tup{a}{b})}{\snd{(\tup{a}{b})}} \jdeq \tup{a}{b} .\]
 因此, \[ \refl{\tup{a}{b}} : \id{\tup{\fst(\tup{a}{b})}{\snd{(\tup{a}{b})}}}{\tup{a}{b}} \]
是良好类型, 因为所有的等同都是定义等同的. 

更一般地说, 这种定义依赖函数的方法意味着, 如果要为一个乘积的所有元素证明一个性质, 只需为它的标准元素, 即有序对子证明即可。对于自然数这样的归纳类型, 类似的性质可以通过归纳来证明因此在通用情况, 如果我们像上面一样应用这个原理, 我们得到乘积类型的\define{归纳}函数: 给定 $A,B : \UU$ 我们有 \symlabel{defn:induction-times}%
\[ \ind{A\times B} : \prd{C:A \times B \to \UU}
\Parens{\prd{x:A}{y:B} C(\tup{x}{y})} \to \prd{x:A \times B} C(x) \]
和这个定义等式  \[ \ind{A\times B}(C,g,\tup{a}{b}) \defeq g(a)(b). \]
类似的, 我们可以说, 定义在对子上的依赖函数, 来自笛卡尔积的\define{归纳原理}\index{归纳原理}%
\index{归纳原理!积的}%
 很容易发现,递归就是 $C$ 为常量的特殊的归纳. 归纳描述了乘积类型中元素的使用方法, 归纳也被称为\define{(依赖)消除器}, \indexsee{消除器!归纳类型的!依赖}{归纳原理}%
递归被称为\define{非依赖消除器}. \indexsee{消除器!归纳类型的!非依赖}{递归原理}%
\indexsee{非依赖消除器}{递归原理}%
\indexsee{依赖消除器}{归纳原理}%

% We can read induction propositionally as saying that a property which
% is true for all pairs holds for all elements of the product type.

单元类型的归纳比它的递归子更有用:  \symlabel{defn:induction-unit}%
\[ \ind{\unit} : \prd{C:\unit \to \UU} C(\ttt) \to \prd{x:\unit}C(x)\]
和定义等式 \[ \ind{\unit}(C,c,\ttt) \defeq c. \]
归纳让我们可以证明 $\unit$ 的唯一性原理, 只要假设它唯一的居留元是 $\ttt$. 即, 我们可以构造 \label{uniquenessunit}
\[\uniq{\unit} : \prd{x:\unit} \id{x}{\ttt} \]
通过这个定义等式 \[\uniq{\unit}(\ttt) \defeq \refl{\ttt} \]
或者使用归纳: \[\uniq{\unit} \defeq \ind{\unit}(\lamu{x:\unit} \id{x}{\ttt},\refl{\ttt}). \]

\index{类型!积|)}%
\index{类型!单元|)}%