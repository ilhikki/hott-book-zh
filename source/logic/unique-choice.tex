\index{唯一!选择|(defstyle}%
\indexsee{公理!选择!唯一}{唯一选择}%

接下来的内容是平凡的, 但又是很有用的.

\begin{lem}
    \label{thm:prop-equiv-trunc}
    如果 $P$ 是纯命题, 那么 $\eqv P {\brck P}$.
\end{lem}
\begin{proof}
    显然, 根据定义, 有 $P\to \brck{P}$.
    然后因为 $P$ 是纯命题,  将 $\brck P$ 的泛性质应用于 $\idfunc[P] :P\to P$ 得到 $\brck P \to P$.
    这些函数互为准逆, 因为 \cref{lem:equiv-iff-hprop}.
\end{proof}

其中重要的结论如下.

\begin{cor}[The principle of unique choice]
    \label{cor:UC}
    假设类型族 $P:A\to \type$ 满足
    \begin{enumerate}
        \item 对于每个 $x$, 类型 $P(x)$ 是纯命题, 并且
        \item 对于每个 $x$ 有 $\brck {P(x)}$.
    \end{enumerate}
    然后有 $\prd{x:A} P(x)$.
\end{cor}
\begin{proof}
    从这两个假设和上一个引理直接可得.
\end{proof}

这个推论还包含了一种非常有用的推理技巧.
具体来说, 假设知道 $\brck A$, 并且想利用它来构建某个其他类型 $B$ 的元素.
我们希望使用 $A$ 的一个元素, 用于构建 $B$ 的元素, 但是这只有在 $B$ 是纯命题时才可以, 这样才能应用命题截断 $\brck A$ 的归纳原理;
通常我们期望的最好的结果就是证明 $\brck B$.
%
作为替代, 可以扩展 $B$, 通过添加额外的数据, 来\emph{唯一地}表征希望构建的对象.
具体来说, 定义一个性质 $Q:B\to\type$ 使得 $\sm{x:B} Q(x)$ 是纯命题.
然后从 $A$ 的一个元素, 构造出 $b:B$ 并满足 $Q(b)$, 从而可以从 $\brck A$ 构建 $\brck{\sm{x:B} Q(x)}$, 并且因为 $\brck{\sm{x:B} Q(x)}$ 等价于 $\sm{x:B} Q(x)$, 可以从中投影出 $B$ 的一个元素.
在 \cref{ex:decidable-choice} 中有一个例子.

集合论中, 也存在类似的问题, 尽管表现方式不同.
如果尝试定义函数 $f: A \to B$, 并依赖于 $a : A$ 的一个元素, 我们只能够证明某个 $b : B$ 的存在, 这并没有完成,因为需要实际的给出 $B$ 的一个元素, 而不是仅仅证明它存在.
一种选择是将论证细化到证明 $b : B$ 的唯一性, 就像在我们类型论做的那样.
但是在集合论中, 这个问题通常可以被避免, 只需应用选择公理, 它可以挑选我们需要的元素.
但是在同伦类型论中, 除了避免使用选择公理的想法以外, 可用的选择公理的形式也更少适用, 因为这要求选择的定义域是\emph{集合}.
因此, 如果 $A$ 不是集合 (比如可能是一个 $\UU$), 就没有一致的选择形式允许为每个 $a : A$ 直接挑选 $B$ 中的一个元素, 用来定义 $f(a)$.

\index{唯一!选择|)}%

