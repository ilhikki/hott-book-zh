\index{截断!命题|(defstyle}%
\indexsee{type!squash}{truncation, propositional}%
\indexsee{squash type}{truncation, propositional}%
\indexsee{bracket type}{truncation, propositional}%
\indexsee{type!bracket}{truncation, propositional}%
\emph{命题截断}, 也被称为 \emph{$(-1)$-截断}, \emph{bracket type}, 或 \emph{挤压类型}, 是一种额外的类型构造器, 它把类型 ``挤压'' 或 ``截断'' 为一个纯命题, 遗忘该类型的居留元除了它们是否存在外的信息.

准确地说, 对于任何类型 $A$, 有类型 $\brck{A}$.
它有两个构造器:
\begin{itemize}
    \item 对于 $a:A$ 有 $\bproj a : \brck A$.
    \item 对于任何 $x,y:\brck A$, 有 $x=y$.
\end{itemize}
第一个构造器意味着若 $A$ 被居留, 那么 $\brck A$ 也如此.
第二个确定了 $\brck A$ 是纯命题; 我们通常不会为这个事实的证明指定名字.

\index{递归原理!截断的}%
$\brck A$ 的递归原理表示:
\begin{itemize}
    \item 如果 $B$ 是纯命题而且有 $f:A\to B$, 那么存在一个归纳函数 $g:\brck A \to B$ 对于所有 $a:A$ 满足 $g(\bproj a) \jdeq f(a)$.
\end{itemize}
换句话说, 任何纯命题, 如果可以从 $A$ (被居留) 可以推导出来, 那么也可以从 $\brck A$ 推导出来.
因此, $\brck A$, 作为一个纯命题, 除了 $A$ 被居留外的任何信息都不存在.
($\brck A$ 的归纳原理也是存在的, 但是并没有更加有用; 参见 \cref{ex:prop-trunc-ind}.)

在 \cref{ex:lem-brck,ex:impred-brck,sec:hittruncations} 会描述一些构造 $\brck{A}$ 的更一般的方法.
目前, 仅仅是假定为与 \cref{cha:typetheory} 的规则并列的额外规则.

根据命题截断, 可以将 ``纯命题的逻辑'' 扩展到析取和存在量词.
也就是说, $\brck{A+B}$ 是 ``$A$ 或 $B$'' 的纯命题版本, 它不会 ``记住'' 那个析取项为真的信息.

截断的递归原则意味着\emph{当试图证明一个纯粹命题时}, 我们仍然可以对 $\brck{A+B}$ 进行情况分析.
也就是, 假设有 $u:\brck{A+B}$ 而试图证明纯命题 $Q$.
换句话说, 试图定义 $\brck{A+B} \to Q$ 的元素.
由于 $Q$  是纯命题, 根据命题截断的递归原则, 定义元素 $A+B\to Q$ 即可.
但现在我们可以在 $A+B$ 上进行情况分析.

类似地, 对于类型族 $P:A\to\type$, 可以考虑 $\brck{\sm{x:A} P(x)}$, 它是 ``存在 $x:A$ 满足 $P(x)$'' 的纯命题版本.
关于析取, 结合截断和 $\Sigma$-类型的归纳原则, 如果有类型为 $\brck{\sm{x:A} P(x)}$ 的假设, \emph{在试图证明一个纯粹命题时} 可以引入新的假设 $x:A$ 和 $y:P(x)$ .
换句话说, 如果知道存在某个 $x:A$ 使得 $P(x)$ 成立, 但我们手头没有特定的 $x$, 可以自由使用这样的 $x$, 只要不试图构造可能依赖于特定 $x$ 的内容.
要求目标类型是一个纯粹命题表达了结果与证明的独立性, 因为这样类型的所有可能成员都必须相等.

在 \cref{cha:real-numbers,cha:set-math} 中主要处理集合和纯粹命题的集合水平数学, 因此使用传统的逻辑符号来表示 ``命题截断逻辑'' 会更加方便.

\begin{defn}
    \label{defn:logical-notation}
    使用截断定义 \define{传统逻辑符号}
    \indexdef{implication}%
    \indexdef{traditional logical notation}%
    \indexdef{logical notation, traditional}%
    \index{量词}%
    \indexsee{existential quantifier}{quantifier, existential}%
    \index{量词!存在}%
    \indexsee{universal!quantifier}{quantifier, universal}%
    \index{量词!全称}%
    \indexdef{conjunction}%
    \indexdef{disjunction}%
    \indexdef{true}%
    \indexdef{false}%
    如下, 其中 $P$ 和 $Q$ 代表纯命题 (或它们的族):
        {\allowdisplaybreaks
    \begin{align*}
        \top            &\ \defeq \ \unit \\
        \bot            &\ \defeq \ \emptyt \\
        P \land Q       &\ \defeq \ P \times Q \\
        P \Rightarrow Q &\ \defeq \ P \to Q \\
        P \Leftrightarrow Q &\ \defeq \ P = Q \\
        \neg P          &\ \defeq \ P \to \emptyt \\
        P \lor Q        &\ \defeq \ \brck{P + Q} \\
        \fall{x : A} P(x) &\ \defeq \ \prd{x : A} P(x) \\
        \exis{x : A} P(x) &\ \defeq \ \Brck{\sm{x : A} P(x)}
    \end{align*}}
\end{defn}

符号 $\land$ 和 $\lor$ 在同伦论中也用于表示点空间的粘合积和楔积, 在 \cref{cha:hits} 中会介绍它们.
技术上这可能会引发潜在的冲突, 但通常不会导致混淆.

类似地, 在讨论 \cref{subsec:prop-subsets} 时, 可以使用传统的符号表示交集, 并集, 和补集:
\indexdef{intersection!of subsets}%
\symlabel{intersection}%
\indexdef{union!of subsets}%
\symlabel{union}%
\indexdef{complement, of a subset}%
\symlabel{complement}%
\begin{align*}
    \setof{x:A | P(x)} \cap \setof{x:A | Q(x)}
    &\defeq \setof{x:A | P(x) \land Q(x)},\\
    \setof{x:A | P(x)} \cup \setof{x:A | Q(x)}
    &\defeq \setof{x:A | P(x) \lor Q(x)},\\
    A \setminus \setof{x:A | P(x)}
    &\defeq \setof{x:A | \neg P(x)}.
\end{align*}
当然, 当没有排中律 \LEM{} 时, 后者不是通常意义上的 ``补集'': 不一定对于集合 $A$ 中的每个子集 $B$ 都有 $B \cup (A\setminus B) = A$.

\index{截断!命题|)}%
\index{纯命题|)}%
\index{逻辑!纯命题的|)}%

