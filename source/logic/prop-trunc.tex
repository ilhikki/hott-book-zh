\index{truncation!propositional|(defstyle}%
\indexsee{type!squash}{truncation, propositional}%
\indexsee{squash type}{truncation, propositional}%
\indexsee{bracket type}{truncation, propositional}%
\indexsee{type!bracket}{truncation, propositional}%
The \emph{propositional truncation}, also called the \emph{$(-1)$-truncation}, \emph{bracket type}, or \emph{squash type}, is an additional type former which ``squashes'' or ``truncates'' a type down to a mere proposition, forgetting all information contained in inhabitants of that type other than their existence.

More precisely, for any type $A$, there is a type $\brck{A}$.
It has two constructors:
\begin{itemize}
\item For any $a:A$ we have $\bproj a : \brck A$.
\item For any $x,y:\brck A$, we have $x=y$.
\end{itemize}
The first constructor means that if $A$ is inhabited, so is $\brck A$.
The second ensures that $\brck A$ is a mere proposition; usually we leave the witness of this fact nameless.

\index{recursion principle!for truncation}%
The recursion principle of $\brck A$ says that:
\begin{itemize}
\item If $B$ is a mere proposition and we have $f:A\to B$, then there is an induced $g:\brck A \to B$ such that $g(\bproj a) \jdeq f(a)$ for all $a:A$.
\end{itemize}
In other words, any mere proposition which follows from (the inhabitedness of) $A$ already follows from $\brck A$.
Thus, $\brck A$, as a mere proposition, contains no more information than the inhabitedness of $A$.
(There is also an induction principle for $\brck A$, but it is not especially useful; see \cref{ex:prop-trunc-ind}.)

In \cref{ex:lem-brck,ex:impred-brck,sec:hittruncations} we will describe some ways to construct $\brck{A}$ in terms of more general things.
For now, we simply assume it as an additional rule alongside those of \cref{cha:typetheory}.

With the propositional truncation, we can extend the ``logic of mere propositions'' to cover disjunction and the existential quantifier.
Specifically, $\brck{A+B}$ is a mere propositional version of ``$A$ or $B$'', which does not ``remember'' the information of which disjunct is true.

The recursion principle of truncation implies that we can still do a case analysis on $\brck{A+B}$ \emph{when attempting to prove a mere proposition}.
That is, suppose we have an assumption $u:\brck{A+B}$ and we are trying to prove a mere proposition $Q$.
In other words, we are trying to define an element of $\brck{A+B} \to Q$.
Since $Q$ is a mere proposition, by the recursion principle for propositional truncation, it suffices to construct a function $A+B\to Q$.
But now we can use case analysis on $A+B$.

Similarly, for a type family $P:A\to\type$, we can consider $\brck{\sm{x:A} P(x)}$, which is a mere propositional version of ``there exists an $x:A$ such that $P(x)$''.
As for disjunction, by combining the induction principles of truncation and $\Sigma$-types, if we have an assumption of type $\brck{\sm{x:A} P(x)}$, we may introduce new assumptions $x:A$ and $y:P(x)$ \emph{when attempting to prove a mere proposition}.
In other words, if we know that there exists some $x:A$ such that $P(x)$, but we don't have a particular such $x$ in hand, then we are free to make use of such an $x$ as long as we aren't trying to construct anything which might depend on the particular value of $x$.
Requiring the codomain to be a mere proposition expresses this independence of the result on the witness, since all possible inhabitants of such a type must be equal.

For the purposes of set-level mathematics in \cref{cha:real-numbers,cha:set-math},
where we deal mostly with sets and mere propositions, it is convenient to use the
traditional logical notations to refer only to ``propositionally truncated logic''.

\begin{defn} \label{defn:logical-notation}
  We define \define{traditional logical notation}
  \indexdef{implication}%
  \indexdef{traditional logical notation}%
  \indexdef{logical notation, traditional}%
  \index{quantifier}%
  \indexsee{existential quantifier}{quantifier, existential}%
  \index{quantifier!existential}%
  \indexsee{universal!quantifier}{quantifier, universal}%
  \index{quantifier!universal}%
  \indexdef{conjunction}%
  \indexdef{disjunction}%
  \indexdef{true}%
  \indexdef{false}%
  using truncation as follows, where $P$ and $Q$ denote mere propositions (or families thereof):
  {\allowdisplaybreaks
  \begin{align*}
    \top            &\ \defeq \ \unit \\
    \bot            &\ \defeq \ \emptyt \\
    P \land Q       &\ \defeq \ P \times Q \\
    P \Rightarrow Q &\ \defeq \ P \to Q \\
    P \Leftrightarrow Q &\ \defeq \ P = Q \\
    \neg P          &\ \defeq \ P \to \emptyt \\
    P \lor Q        &\ \defeq \ \brck{P + Q} \\
    \fall{x : A} P(x) &\ \defeq \ \prd{x : A} P(x) \\
    \exis{x : A} P(x) &\ \defeq \ \Brck{\sm{x : A} P(x)}
  \end{align*}}
\end{defn}

The notations $\land$ and $\lor$ are also used in homotopy theory for the smash product and the wedge of pointed spaces, which we will introduce in \cref{cha:hits}.
This technically creates a potential for conflict, but no confusion will generally arise.

Similarly, when discussing subsets as in \cref{subsec:prop-subsets}, we may use the traditional notation for intersections, unions, and complements:
\indexdef{intersection!of subsets}%
\symlabel{intersection}%
\indexdef{union!of subsets}%
\symlabel{union}%
\indexdef{complement, of a subset}%
\symlabel{complement}%
\begin{align*}
  \setof{x:A | P(x)} \cap \setof{x:A | Q(x)}
  &\defeq \setof{x:A | P(x) \land Q(x)},\\
  \setof{x:A | P(x)} \cup \setof{x:A | Q(x)}
  &\defeq \setof{x:A | P(x) \lor Q(x)},\\
  A \setminus \setof{x:A | P(x)}
  &\defeq \setof{x:A | \neg P(x)}.
\end{align*}
Of course, in the absence of \LEM{}, the latter are not ``complements'' in the usual sense: we may not have $B \cup (A\setminus B) = A$ for every subset $B$ of $A$.

\index{truncation!propositional|)}%
\index{mere proposition|)}%
\index{logic!of mere propositions|)}%

