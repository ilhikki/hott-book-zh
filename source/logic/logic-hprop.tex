\index{逻辑!纯命题的|(}%
注意\cref{sec:types-vs-sets}中, 类型论只有一个基础概念 (类型), 集合论有两个基础概念: 集合和类型.
因此, 经典数学家\index{数学!经典的}习惯于分开处理这两种对象.

在类型论中可能还原类似的区分, 其中集合论的命题, 在类型论中被表现为\emph{纯}命题的类型(或者类型族).
在很多时候, 逻辑的连词和量词可以被通过限制对应的类型构造器为纯命题来表示.
当然, 需要确保问题中的类型构造器保留了纯命题.

\begin{eg}
  如果 $A$ 和 $B$ 是纯命题, 那么 $A\times B$ 也是.
  使用乘积中路径的特征即可, 类似于 \cref{thm:isset-prod}, 而且更简单.
  因此, 连词 ``与'' 保留了纯命题.
\end{eg}

\begin{eg}\label{thm:isprop-forall}
  如果 $A$ 是一个类型而且 $B:A\to \type$ 满足对于所有 $x:A$ 类型 $B(x)$ 是命题, 那么 $\prd{x:A} B(x)$ 是纯命题.
  证明类似于 \cref{thm:isset-forall} 而且更佳简单: 给定 $f,g:\prd{x:A} B(x)$, 对于任何 $x:A$ 有 $f(x)=g(x)$ 因为 $B(x)$ 是纯命题.
  然后根据函数的外延性, 有 $f=g$.

  特别地, 如果 $B$ 是纯命题, $A\to B$ 也是, 无论 $A$ 是否为纯命题.
  更特殊地, 因为 \emptyt 是纯命题, 所以 $\neg A \jdeq (A\to\emptyt)$ 也是.
  \index{量词!通用的}%
  因此, 连词 ``蕴含'' 和 ``非'' 保留纯命题, 量词 ``对于所有'' 也是.
\end{eg}

另一方面, 一些类型构造不保留纯命题.
即使 $A$ 和 $B$ 都是纯命题, $A+B$ 也通常不是.
例如, \unit 是纯命题, 但 $\bool=\unit+\unit$ 不是.
逻辑上来讲, $A+B$ 是一种``纯构造性''的``或'': 它是一个证明, 而且包含了额外的信息, 即\emph{哪个}分支为真.
某些时候这很有用, 但是如果需要保留纯命题的更经典的``或'', 需要一个方法来``截取''这个类型, 通过抛弃额外的信息.

\index{量词!外延的}%
类似的问题在 $\Sigma$-类型 $\sm{x:A} P(x)$ 也存在.
这是关于 ``存在 $x:A$ 满足 $P(x)$'' 的一个纯构造性解释, 而且包含了证据 $x$, 因此它通常也不是纯命题. 即使 $P(x)$ 是纯命题.
(回顾在 \cref{subsec:prop-subsets} 观察的, $\sm{x:A} P(x)$ 可以被视为是 ``满足 $P(x)$ 的 $x:A$ 的子集''.)

