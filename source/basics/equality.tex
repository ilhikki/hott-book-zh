\index{类型!恒等|(}%
\index{路径|(}%
\index{.infinity-groupoid@$\infty$-groupoid!类型的结构|(}%
现在从归纳原理开始派生高阶广群结构. 从平等的对称性开始, 即拓扑学语言的``路径可逆''. 

\begin{lem}\label{lem:opp}
对于每个类型 $A$ 和每个 $x,y:A$ 有一个函数
\begin{equation*}
(x= y)\to(y= x)
\end{equation*}
表示为 $p\mapsto \opp{p}$, 于是对于每个 $x:A$ 有 $\opp{\refl{x}}\jdeq\refl{x}$.
我们称 $\opp{p}$ 是 $p$ 的 \define{逆}.
\indexdef{路径!逆}%
\indexdef{逆!路径的}%
\index{等同!的对称}%a
\index{对称!等同的}%
\end{lem}

因为这是我们第一次使用 ``引理'' 或者 ``定理'', 让我们停下来考虑它的含义. 回顾命题 (可以被证明的陈述) 即类型, 而引理和定理是 (已经被证明的陈述) 即 \emph{被居留的}类型. 因此, 引理或者定理的陈述应该可以被转换为类型, 就像 \cref{sec:pat}, 而且它把证明转换为该类型的居留元. 按照通用量词``对于所有''的理解, 与 \cref{lem:opp} 相当的类型是  \[ \prd{A:\UU}{x,y:A} (x= y)\to(y= x). \]
\cref{lem:opp} 的证明包含了这个类型元素的构造, 即对于一些 $f$ 派生判断 $f:\prd{A:\UU}{x,y:A} (x= y)\to(y= x)$. 然后对于该元素 $f$, 引入符号 $\opp{(\blank)}$, 其中省略了参数 $A$, $x$, 和 $y$ 并从上下文中推论出. (就像 \cref{sec:types-vs-sets} 说的, 第二的陈述句 ``$\opp{\refl{x}}\jdeq\refl{x}$ 对于每个 $x:A$'' 应该被当作 一个分开的判断.) 

\begin{proof}[第一个证明]
假设给定 $A:\UU$,
令 $D:\prd{x,y:A}(x= y) \to \type$ 为类型族, 并由 $D(x,y,p)\defeq (y= x)$ 定义.
换句话说, $D$ 是一个函数, 传入任何 $x,y:A$ 和 $p:x=y$ 返回一个类型 $y=x$.
于是有该元素
\begin{equation*}
d\defeq \lam{x} \refl{x}:\prd{x:A} D(x,x,\refl{x}).
\end{equation*}
因此, 恒等类型的归纳原理提供了一个元素
\narrowequation{ \indid{A}(D,d,x,y,p): (y= x)}
并对每个 $p:(x= y)$ 成立.
现在可以定义所需函数 $\opp{(\blank)}$ 为 $\lam{p} \indid{A}(D,d,x,y,p)$, 即i令 $\opp{p} \defeq \indid{A}(D,d,x,y,p)$.
该转换规则~\eqref{eq:Jconv} 提供了所需的 $\opp{\refl{x}}\jdeq \refl{x}$.
\end{proof}

我们使用了这种非常形式化的证明风格, 在对恒等类型归纳规则不熟悉时, 非常有帮助. 甚至更形式化地, \cref{lem:opp} 和其证明都包含于判断 \begin{narrowmultline*}
\lam{A}{x}{y}{p} \indid{A}((\lam{x}{y}{p} (y=x)), (\lam{x} \refl{x}), x, y, p)
\narrowbreak : \prd{A:\UU}{x,y:A} (x= y)\to(y= x)
\end{narrowmultline*}
(以及额外的等同判断). 不过, 最终我们还是更喜欢更自然的语言, 就像下面的等价的证明. 

\begin{proof}[第二个证明]
我们像构造, 对于每个 $x,y:A$ 和 $p:x=y$, 有元素 $\opp{p}:y=x$.
通过归纳, 当 $y$ 是 $x$ 且 $p$ 是 $\refl{x}$ 的情况已经足够.
不过在这个情况下, $p$ 的类型 $x=y$ 和类型 $y=x$ 即尝试构造的 $\opp{p}$ 都是简单的 $x=x$.
因此, 在 ``自反的情况'', 可以定义 $\opp{\refl{x}}$ 就是简单的 $\refl{x}$.
这个通用情况遵循归纳原理, 和转换规则 $\opp{\refl{x}}\jdeq\refl{x}$ 恰好是给出的自反情况的证明.
\end{proof}

接下来会用两种风格来写证明, 来帮助读者喜欢后一种. 接下来证明等同的转递性, 即 ``串联路径''. 

\begin{lem}\label{lem:concat}
对于每个类型 $A$ 和每个类型 $x,y,z:A$ 存在一个函数
\begin{equation*}
(x= y) \to (y= z)\to (x= z),
\end{equation*}
写作 $p \mapsto q \mapsto p\ct q$, 于是对于任意 $x:A$ 有 $\refl{x}\ct \refl{x}\jdeq \refl{x}$.
$p\ct q$ 被称为\define{串联}或 $p$ 和 $q$ 的\define{复合}.
\indexdef{路径!串联}%
\indexdef{路径!复合}%
\indexdef{路径的串联}%
\indexdef{复合!路径的}%
\index{等同!的传递性}%
\index{传递性!等同的}%
\end{lem}

注意我们选择与函数复合相反的顺序来表示路径串联: 从 $p:x=y$ 和 $q:y=z$ 得到 $p\ct q : x=z$, 而从 $f:A\to B$ 和 $g:B\to C$ 得到 $g\circ f : A\to C$ (参见 \cref{ex:composition}). 

\begin{proof}[第一个证明]
所需函数类型是 $\prd{x,y,z:A} (x= y) \to (y= z)\to (x= z)$.
我们将定义等价的类型 $\prd{x,y:A} (x= y) \to \prd{z:A} (y= z)\to (x= z)$ 来代替, 这允许我们应用两次路径归纳.
令 $D:\prd{x,y:A} (x=y) \to \type$ 为类型族
\begin{equation*}
D(x,y,p)\defeq \prd{z:A}{q:y=z} (x=z).
\end{equation*}
注意 $D(x,x,\refl x) \jdeq \prd{z:A}{q:x=z} (x=z)$.
因此, 为了应用恒等类型的归纳原理到这个 $D$, 需要一个类型函数
\begin{equation}\label{eq:concatD}
\prd{x:A} D(x,x,\refl{x})
\end{equation}
也就是说类型
\[ \prd{x,z:A}{q:x=z} (x=z). \]
现在令 $E:\prd{x,z:A}{q:x=z}\type$ 为类型族 $E(x,z,q)\defeq (x=z)$.
注意 $E(x,x,\refl x) \jdeq (x=x)$.
因此, 有此函数
\begin{equation*}
e(x) \defeq \refl{x} : E(x,x,\refl{x}).
\end{equation*}
通过恒等类型归纳原理应用到 $E$, 得到一个函数
\begin{equation*}
d : \prd{x,z:A}{q:x=z} E(x,z,q).
\end{equation*}
但是 $E(x,z,q)\jdeq (x=z)$, 所以 $d$ 的类型是~\eqref{eq:concatD}.
因此, 我们可以使用该函数 $d$ 然后应用恒等类型的归纳原理到 $D$, 来得到所需类型的函数
\begin{equation*}
\prd{x,y:A} (x= y) \to \prd{z:A} (y= z)\to (x= z)
\end{equation*}
因此 $\prd{x,y,z:A} (y=z) \to (x=y) \to (x=z)$.
这两个归纳原则的转换规则给了我们 $\refl{x}\ct \refl{x}\jdeq \refl{x}$ 对于任何 $x:A$.
\end{proof}

\begin{proof}[第二个证明]
对于每个 $x,y,z:A$ 和每个 $p:x=y$ 和 $q:y=z$, an 元素 of $x=z$, 我们想构造.
通过在 $p$ 上归纳, 假设 $y$ 为 $x$ 和 $p$ 是 $\refl{x}$ 即可.
这个情况下, $q$ 的类型 $y=z$ 是 $x=z$.
现在在 $q$ 上归纳, 假设 $z$ 是 $x$ 和 $q$ 是 $\refl{x}$ 即可.
但是在这个情况下, $x=z$ 是 $x=x$, 而我们有 $\refl{x}:(x=x)$.
\end{proof}

读者可能会觉的我们对这个引理给了过于复杂的证明. 事实上, 在 $p$ 上归纳后就可以停止, 因为需要的就是同等 $x=z$, 我们已经有了这样的等同, 即 $q$. 为什么还在 $q$ 上的还做了另一个归纳? 

答案就是, 像导论中描述的一样, 我们在做\emph{证明相关}的数学. \index{数学!证明相关}%
证明一个引理时, 我们在定义元素的一个居留元, 这和证明过程中定义的\emph{特殊}元素有关, 而不仅仅是类型被这个元素居留(即引理的\emph{陈述}). \cref{lem:concat} 有三个明显的证明: 可以在 $p$ 上归纳, 在 $q$ 上归纳, 或者一起归纳.
如果以三种不同的方式来证明, 那么将拥有同一类型的三个不同元素. 不难证明这三个元素是等同的 (参见 \cref{ex:basics:concat}), 但因为他们不是\emph{定义}等同, 因此可以偏爱其中一个理由. 

在 \cref{lem:concat} 的情况下, 差异取决于计算规则. 如果使用在 $p$ 上单次归纳来证明引理, 那么可以得到形式为 $\refl{y} \ct q \jdeq q$ 的计算规则. 如果在 $q$ 上单次归纳来证明, 可以代替为 $p\ct\refl{y}\jdeq p$, 而归纳两次 (如我们所做的) 仅给出 $\refl{x}\ct\refl{x} \jdeq \refl{x}$. 

\index{数学!形式}%
在形式数学时, 非对称计算规则有时很方便, 因为它们允许计算机自动简化更多事情. 不过, 在非形式的数学中, 甚至有争议的不形式的情况, 串联操作有时会令人困惑, 因为它不对称的行为而且必须记住哪变是``特殊''的一侧. 对称地对待两边有益于更健壮的证明; 这也是为什么那个证明这样做的原因. (不过, 诚然这是风格上的选择.) 

下面的表格总结了目前所做的``等同'', ``同论'', ``高阶广群"的观点. \begin{center}
\medskip
\begin{tabular}{ccc}
\toprule
等同 &同伦 &$\infty$-Groupoid\\
\midrule
自反\index{等同!的自反} &常量路径 &恒等态射\\
对称性\index{等同!对称性} &路径的逆 &态射的逆\\
传递性\index{等同!的传递性} &路径串联 &态射复合\\
\bottomrule
\end{tabular}
\medskip
\end{center}

实际上, 传递性经常应用于通过一系列中间步骤证明等同. 我们会使用像 $a=b=c=d$ 这样的通用符号. 如果中间表达式很长, 或者想指定每个等同的见证, 可以写作 \begin{align*}
a &= b &\text{(通过 $p$)}\\ &= c &\text{(通过 $q$)} \\ &= d &\text{(通过 $r$)}.
\end{align*}
在每种情况, 这个符号都表示元素 $(p\ct q)\ct r: (a=d)$ 的构造. (它是左结合的, 尽管从 \cref{thm:omg}\ref{item:omg4} 来看区别不大.) 如果 $b$ 与 $c$ 是判断等同的, 那么可以写作 \begin{align*}
a &= b &\text{(通过 $p$)}\\ &\jdeq c \\ &= d &\text{(通过 $r$)}
\end{align*}
来表示 $p\ct r : (a=d)$ 的构造. 同样遵循普通数学惯例, 不需要显示为符号 (``通过 $p$'' 和 ``通过 $r$'') 显式地提供见证; 而是允许简单提及最重要的 (或者不明显的) 构造见证的要素. 例如, 如果``引理 A'' 指出对于所有 $x$ 和 $y$ 我们有 $f(x)=g(y)$, 那么我们可以写 ``通过引理 A'' 作为 $f(a) = g(b)$ 的理由, 相信读者可以演绎应用引理 A 到 $x\defeq a$ 和$y\defeq b$. 我们也可能会完全忽略理由, 如果我们相信读者有能力猜到它. 

现在, 因为证明相关的原因, 我们无法在证明等同的``对称性''与``传递性''后就停下来: 我们需要知道等式上的\emph{操作}是表现良好的. (在集合论中这个问题是不可见的, 因为对称性和传递性是等同的纯\emph{形式}, 而不是路径上的结构.) 从同伦论的观点来看, 串联和逆只是高阶广群的``第一级'' --- 我们同样需要这些操作的一致性\index{一致性}定律, 以及在更高维度的类似运算. 例如, 我们知道串联是\emph{结合}的, 而逆提供了串联的\emph{逆}. 

\begin{lem}\label{thm:omg}%[The $\omega$-groupoid structure of types]
\index{结合律!路径串联的}%
\index{单元!路径串联法则}%
提供 $A:\type$, $x,y,z,w:A$, $p:x= y$, $q:y = z$ 和 $r:z=w$.
于是有以下:
\begin{enumerate}
\item $p= p\ct \refl{y}$ and $p = \refl{x} \ct p$.\label{item:omg1}
\item $\opp{p}\ct p= \refl{y}$ and $p\ct \opp{p}= \refl{x}$.\label{item:omg2}
\item $\opp{(\opp{p})}= p$.\label{item:omg3}
\item $p\ct (q\ct r)= (p\ct q)\ct r$.\label{item:omg4}
\end{enumerate}
\end{lem}

Note, 特别的, that \ref{item:omg1}--\ref{item:omg4} 是命题等同本身, 存在于恒等类型\emph{的}恒等类型中, 就像 $p=_{x=y}q$ 对于 $p,q:x=y$. 在拓扑上, 他们是 \emph{路径的路径}, 即同伦. 事实就是, 当串联路径 $p$ 和被反转的路径 $\opp p$ 时, 不会确实得到一个常量路径 (相当于在类型论中的等同 $\refl{}$) --- 而是同伦, 或者路径, 它从 $p\ct\opp p$ 到常量路径. 

\begin{proof}[\cref{thm:omg} 的证明]
所有的证明使用等同的归纳原则.
\begin{enumerate}
\item \emph{第一个证明:} 令 $D:\prd{x,y:A} (x=y) \to \type$ 为类型族, 并以此给定
\begin{equation*}
D(x,y,p)\defeq (p= p\ct \refl{y}).
\end{equation*}
然后 $D(x,x,\refl{x})$ 是 $\refl{x}=\refl{x}\ct\refl{x}$.
因为 $\refl{x}\ct\refl{x}\jdeq\refl{x}$, 所以 $D(x,x,\refl{x})\jdeq (\refl{x}=\refl{x})$.
因此, 有函数
\begin{equation*}
d\defeq\lam{x} \refl{\refl{x}}:\prd{x:A} D(x,x,\refl{x}).
\end{equation*}
现在恒等类型的归纳原理对于每个 $p:x= y$ 给出一个元素 $\indid{A}(D,d,x,y,p):(p= p\ct\refl{y})$.
另一个等式同样被证明了.

\mentalpause

\noindent
\emph{第二个:} 通过对 $p$ 归纳, 足以假定 $y$ 是 $x$ 和 $p$ 是 $\refl x$.
在这种情况下, 有 $\refl{x}\ct\refl{x}\jdeq\refl{x}$.
\item \emph{第一个证明:} 令 $D:\prd{x,y:A} (x=y) \to \type$ 为类型族, 并以此给定
\begin{equation*}
D(x,y,p)\defeq (\opp{p}\ct p= \refl{y}).
\end{equation*}
然后 $D(x,x,\refl{x})$ 是 $\opp{\refl{x}}\ct\refl{x}=\refl{x}$.
因为 $\opp{\refl{x}}\jdeq\refl{x}$ 和 $\refl{x}\ct\refl{x}\jdeq\refl{x}$, 得到 $D(x,x,\refl{x})\jdeq (\refl{x}=\refl{x})$.
因此发现这个函数
\begin{equation*}
d\defeq\lam{x} \refl{\refl{x}}:\prd{x:A} D(x,x,\refl{x}).
\end{equation*}
现在路径归纳对于任何 $p:x= y$ in $A$ 给定一个元素 $\indid{A}(D,d,x,y,p):\opp{p}\ct p=\refl{y}$.
另一个等同也类似.

\mentalpause

\noindent \emph{第二个证明:} 通过归纳, 足以假定 $p$ 是 $\refl x$.
在这种情况下, 有 $\opp{p} \ct p \jdeq \opp{\refl x} \ct \refl x \jdeq \refl x$.

\item \emph{第一个证明:} 令 $D:\prd{x,y:A} (x=y) \to \type$ 为类型族, 并以此给定
\begin{equation*}
D(x,y,p)\defeq (\opp{\opp{p}}= p).
\end{equation*}
然后 $D(x,x,\refl{x})$ 是这个类型 $(\opp{\opp{\refl x}}=\refl{x})$.
不过因为 $\opp{\refl{x}}\jdeq \refl{x}$ for each $x:A$, 有 $\opp{\opp{\refl{x}}}\jdeq \opp{\refl{x}} \jdeq\refl{x}$, 因此 $D(x,x,\refl{x})\jdeq(\refl{x}=\refl{x})$.
因此发现这个函数
\begin{equation*}
d\defeq\lam{x} \refl{\refl{x}}:\prd{x:A} D(x,x,\refl{x}).
\end{equation*}
仙子路径归纳给定一个元素 $\indid{A}(D,d,x,y,p):\opp{\opp{p}}= p$ for each $p:x= y$.

\mentalpause

\noindent \emph{第二个证明:} 通过归纳, 足以假定 $p$ 是 $\refl x$.
在这种情况下, 有 $\opp{\opp{p}}\jdeq \opp{\opp{\refl x}} \jdeq \refl x$.

\item \emph{第一个证明:} 令 $D_1:\prd{x,y:A} (x=y) \to \type$ 为类型族, 并以此给定
\begin{equation*}
D_1(x,y,p)\defeq\prd{z,w:A}{q:y= z}{r:z= w} \big(p\ct (q\ct r)= (p\ct q)\ct r\big).
\end{equation*}
然后 $D_1(x,x,\refl{x})$ 就是
\begin{equation*}
\prd{z,w:A}{q:x= z}{r:z= w} \big(\refl{x}\ct(q\ct r)= (\refl{x}\ct q)\ct r\big).
\end{equation*}
为了狗总此类型的元素, 令 $D_2:\prd{x,z:A} (x=z) \to \type$ 为类型族
\begin{equation*}
D_2 (x,z,q) \defeq \prd{w:A}{r:z=w} \big(\refl{x}\ct(q\ct r)= (\refl{x}\ct q)\ct r\big).
\end{equation*}
然后 $D_2(x,x,\refl{x})$ 是
\begin{equation*}
\prd{w:A}{r:x=w} \big(\refl{x}\ct(\refl{x}\ct r)= (\refl{x}\ct \refl{x})\ct r\big).
\end{equation*}
To 构造 an 元素 of \emph{this} 类型, let $D_3:\prd{x,w:A} (x=w) \to \type$ be the 类型 族
\begin{equation*}
D_3(x,w,r) \defeq \big(\refl{x}\ct(\refl{x}\ct r)= (\refl{x}\ct \refl{x})\ct r\big).
\end{equation*}
然后 $D_3(x,x,\refl{x})$ 就是
\begin{equation*}
\big(\refl{x}\ct(\refl{x}\ct \refl{x})= (\refl{x}\ct \refl{x})\ct \refl{x}\big)
\end{equation*}
它与类型 $(\refl{x} = \refl{x})$ 定义等同, 因此被 $\refl{\refl{x}}$ 所居留.
应用三次路径归纳规则, 得到全部所需类型一个元素.

\mentalpause

\noindent \emph{第二个证明:} 通过归纳, 足够假设 $p$, $q$, 和 $r$ 都是 $\refl x$.
在这中情况下, 有
\begin{align*}
p\ct (q\ct r)
&\jdeq \refl{x}\ct(\refl{x}\ct \refl{x})\\
&\jdeq \refl{x}\\
&\jdeq (\refl{x}\ct \refl x)\ct \refl x\\
&\jdeq (p\ct q)\ct r.
\end{align*}
因此, 我们有 $\refl{\refl{x}}$ 居留于这个类型. \qedhere
\end{enumerate}
\end{proof}

\begin{rmk}
有另外一种定义这种高阶路径的方法.
例如, 在 \cref{thm:omg}\ref{item:omg4} 可以只在一个或者两个路径上归纳归纳路径, 而不是所有三个.
每种都可以缠身\emph{定义}不同的证明, 但是它们彼此相等.
同样, 可以通过回纳证明任意两个特定的证明之间的等同性, 简化问题所有的路径到自反性, 然后就观察到两个证明都简化自己为自反.
\end{rmk}

In view of \cref{thm:omg}\ref{item:omg4}, we will often write $p\ct q\ct r$ for $(p\ct q)\ct r$, and similarly $p\ct q\ct r \ct s$ for $((p\ct q)\ct r)\ct s$ and so on. We choose left-associativity for definiteness, but it makes no real difference. We generally trust the reader to insert instances of \cref{thm:omg}\ref{item:omg4} to reassociate such expressions as necessary. 

We are still not really done with the higher groupoid structure: the paths~\ref{item:omg1}--\ref{item:omg4} must also satisfy their own higher coherence\index{coherence} laws, which are themselves higher paths, \index{associativity!of path concatenation!coherence of}%
\index{globular operad}%
\index{operad}%
\index{groupoid!higher}%
and so on ``all the way up to infinity'' (this can be made precise using e.g.\ the notion of a globular operad). However, for most purposes it is unnecessary to make the whole infinite-dimensional structure explicit. One of the nice things about homotopy type theory is that all of this structure can be \emph{proven} starting from only the inductive property of identity types, so we can make explicit as much or as little of it as we need. 

In particular, in this book we will not need any of the complicated combinatorics involved in making precise notions such as ``coherent structure at all higher levels''. In addition to ordinary paths, we will use paths of paths (i.e.\ elements of a type $p =_{x=_A y} q$), which as remarked previously we call \emph{2-paths}\index{path!2-} or \emph{2-dimensional paths}, and perhaps occasionally paths of paths of paths (i.e.\ elements of a type $r = _{p =_{x=_A y} q} s$), which we call \emph{3-paths}\index{path!3-} or \emph{3-dimensional paths}. It is possible to define a general notion of \emph{$n$-dimensional path} \indexdef{path!n-@$n$-}%
\indexsee{n-path@$n$-path}{path, $n$-}%
\indexsee{n-dimensional path@$n$-dimensional path}{path, $n$-}%
\indexsee{path!n-dimensional@$n$-dimensional}{path, $n$-}%
(see \cref{ex:npaths}), but we will not need it. 

We will, however, use one particularly important and simple case of higher paths, which is when the start and end points are the same. In set theory, the proposition $a=a$ is entirely uninteresting, but in homotopy theory, paths from a point to itself are called \emph{loops}\index{loop} and carry lots of interesting higher structure. Thus, given a type $A$ with a point $a:A$, we define its \define{loop space} \index{loop space}%
$\Omega(A,a)$ to be the type $\id[A]{a}{a}$. We may sometimes write simply $\Omega A$ if the point $a$ is understood from context. 

Since any two elements of $\Omega A$ are paths with the same start and end points, they can be concatenated; thus we have an operation $\Omega A\times \Omega A\to \Omega A$. More generally, the higher groupoid structure of $A$ gives $\Omega A$ the analogous structure of a ``higher group''. 

It can also be useful to consider the loop space\index{loop space!iterated}\index{iterated loop space} \emph{of} the loop space of $A$, which is the space of 2-dimensional loops on the identity loop at $a$. This is written $\Omega^2(A,a)$ and represented in type theory by the type $\id[({\id[A]{a}{a}})]{\refl{a}}{\refl{a}}$. While $\Omega^2(A,a)$, as a loop space, is again a ``higher group'', it now also has some additional structure resulting from the fact that its elements are 2-dimensional loops between 1-dimensional loops. 

\begin{thm}[Eckmann--Hilton]\label{thm:EckmannHilton}
The composition operation on the second loop space
%
\begin{equation*}
\Omega^2(A)\times \Omega^2(A)\to \Omega^2(A)
\end{equation*}
is commutative: $\alpha\ct\beta = \beta\ct\alpha$, for any $\alpha, \beta:\Omega^2(A)$.
\index{Eckmann--Hilton argument}%
\end{thm}

\begin{proof}
First, observe that the composition of $1$-loops $\Omega A\times \Omega A\to \Omega A$ induces an operation \[
\star : \Omega^2(A)\times \Omega^2(A)\to \Omega^2(A)
\]
as follows: consider elements $a, b, c : A$ and 1- and 2-paths, %

\begin{align*}
p &: a = b, &r &: b = c \\
q &: a = b, &s &: b = c \\
\alpha &: p = q, &\beta &: r = s
\end{align*}
%
as depicted in the following diagram (with paths drawn as arrows). % Changed this to xymatrix in the name of having uniform source code,

% maybe the original using xy looked better (I think it was too big).
% It is commented out below in case you want to reinstate it.
\[
\xymatrix@+5em{
{a} \rtwocell<10>^p_q{\alpha}
&
{b} \rtwocell<10>^r_s{\beta}
&
{c}
}
\]
Composing the upper and lower 1-paths, respectively, we get two paths $p\ct r,\ q\ct s : a = c$, and there is then a ``horizontal composition'' %

\begin{equation*}
\alpha\hct\beta : p\ct r = q\ct s
\end{equation*}
%
between them, defined as follows. First, we define $\alpha \rightwhisker r : p\ct r = q\ct r$ by path induction on $r$, so that \[ \alpha \rightwhisker \refl{b} \jdeq \opp{\mathsf{ru}_p} \ct \alpha \ct \mathsf{ru}_q \]
where $\mathsf{ru}_p : p = p \ct \refl{b}$ is the right unit law from \cref{thm:omg}\ref{item:omg1}. We could similarly define $\rightwhisker$ by induction on $\alpha$, or on all paths in sight, resulting in different judgmental equalities, but for present purposes the definition by induction on $r$ will make things simpler. Similarly, we define $q\leftwhisker \beta : q\ct r = q\ct s$ by induction on $q$, so that \[ \refl{b} \leftwhisker \beta \jdeq \opp{\mathsf{lu}_r} \ct \beta \ct \mathsf{lu}_s \]
where $\mathsf{lu}_r$ denotes the left unit law. The operations $\leftwhisker$ and $\rightwhisker$ are called \define{whiskering}\indexdef{whiskering}. Next, since $\alpha \rightwhisker r$ and $q\leftwhisker \beta$ are composable 2-paths, we can define the \define{horizontal composition} \indexdef{horizontal composition!of paths}%
\indexdef{composition!of paths!horizontal}%
by: \[
\alpha\hct\beta\ \defeq\ (\alpha\rightwhisker r) \ct (q\leftwhisker \beta).
\]
Now suppose that $a \jdeq b \jdeq c$, so that all the 1-paths $p$, $q$, $r$, and $s$ are elements of $\Omega(A,a)$, and assume moreover that $p\jdeq q \jdeq r \jdeq s\jdeq \refl{a}$, so that $\alpha:\refl{a} = \refl{a}$ and $\beta:\refl{a} = \refl{a}$ are composable in both orders. In that case, we have \begin{align*}
\alpha\hct\beta
&\jdeq (\alpha\rightwhisker\refl{a}) \ct (\refl{a}\leftwhisker \beta)\\
&= \opp{\mathsf{ru}_{\refl{a}}} \ct \alpha \ct \mathsf{ru}_{\refl{a}} \ct \opp{\mathsf{lu}_{\refl a}} \ct \beta \ct \mathsf{lu}_{\refl{a}}\\
&\jdeq \opp{\refl{\refl{a}}} \ct \alpha \ct \refl{\refl{a}} \ct \opp{\refl{\refl a}} \ct \beta \ct \refl{\refl{a}}\\
&= \alpha \ct \beta.
\end{align*}
(Recall that $\mathsf{ru}_{\refl{a}} \jdeq \mathsf{lu}_{\refl{a}} \jdeq \refl{\refl{a}}$, by the computation rule for path induction.) On the other hand, we can define another horizontal composition analogously by \[
\alpha\hct'\beta\ \defeq\ (p\leftwhisker \beta)\ct (\alpha\rightwhisker s)
\]
and we similarly learn that \[
\alpha\hct'\beta = \beta\ct\alpha.
\]
\index{interchange law}%
But, in general, the two ways of defining horizontal composition agree, $\alpha\hct\beta = \alpha\hct'\beta$, as we can see by induction on $\alpha$ and $\beta$ and then on the two remaining 1-paths, to reduce everything to reflexivity. Thus we have \[\alpha \ct \beta = \alpha\hct\beta = \alpha\hct'\beta = \beta\ct\alpha.
\qedhere
\]
\end{proof}

The foregoing fact, which is known as the \emph{Eckmann--Hilton argument}, comes from classical homotopy theory, and indeed it is used in \cref{cha:homotopy} below to show that the higher homotopy groups of a type are always abelian\index{group!abelian} groups. The whiskering and horizontal composition operations defined in the proof are also a general part of the $\infty$-groupoid structure of types. They satisfy their own laws (up to higher homotopy), such as \[ \alpha \rightwhisker (p\ct q) = (\alpha \rightwhisker p) \rightwhisker q \]
and so on. From now on, we trust the reader to apply path induction whenever needed to define further operations of this sort and verify their properties. 

As this example suggests, the algebra of higher path types is much more intricate than just the groupoid-like structure at each level; the levels interact to give many further operations and laws, as in the study of iterated loop spaces in homotopy theory. Indeed, as in classical homotopy theory, we can make the following general definitions: 

\begin{defn} \label{def:pointedtype}
A \define{pointed type}
\indexsee{pointed!type}{type, pointed}%
\indexdef{type!pointed}%
$(A,a)$ is a type $A:\type$ together with a point $a:A$, called its \define{basepoint}.
\indexdef{basepoint}%
We write $\pointed{\type} \defeq \sm{A:\type} A$ for the type of pointed types in the universe $\type$.
\end{defn}

\begin{defn} \label{def:loopspace}
Given a pointed type $(A,a)$, we define the \define{loop space}
\indexdef{loop space}%
of $(A,a)$ to be the following pointed type:
\[\Omega(A,a)\defeq ((\id[A]aa),\refl a).\]
An element of it will be called a \define{loop}\indexdef{loop} at $a$.
For $n:\N$, the \define{$n$-fold iterated loop space} $\Omega^{n}(A,a)$
\indexdef{loop space!iterated}%
\indexsee{loop space!n-fold@$n$-fold}{loop space, iterated}%
of a pointed type $(A,a)$ is defined recursively by:
\begin{align*}
\Omega^0(A,a)&\defeq(A,a)\\
\Omega^{n+1}(A,a)&\defeq\Omega^n(\Omega(A,a)).
\end{align*}
An element of it will be called an \define{$n$-loop}
\indexdef{loop!n-@$n$-}%
\indexsee{n-loop@$n$-loop}{loop, $n$-}%
or an \define{$n$-dimensional loop}
\indexsee{loop!n-dimensional@$n$-dimensional}{loop, $n$-}%
\indexsee{n-dimensional loop@$n$-dimensional loop}{loop, $n$-}%
at $a$.
\end{defn}

We will return to iterated loop spaces in \cref{cha:hlevels,cha:hits,cha:homotopy}. \index{.infinity-groupoid@$\infty$-groupoid!structure of a type|)}%
\index{type!identity|)}
\index{path|)}%