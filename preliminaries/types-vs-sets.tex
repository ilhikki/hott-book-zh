\label{sec:axioms}

\index{类型论}
同伦类型论是基础的数学语言之一, 是策梅洛-弗兰克尔\index{集合论!策梅洛-弗兰克尔}集合论的替换物. 不过, 它和集合论有一些重要的区别, 可能需要一些时间来适应. 为了谨慎解释这些区别, 需要我们在这本书的剩余部分更加正式. 如导言所说, 我们的目的是\emph{非正式的}描述类型论; 但是对于习惯集合论的数学家来说, 保持缜密可以避免一些常见的误解和错误. 

我们注意到集合论的基础有两个 ``层次'': 一阶逻辑``\index{一阶!逻辑}的演绎系统, 和它所阐述的特定的公理, 比如 ZFC . 因此, 集合论不仅仅和集合有关, 它还讨论关于集合 (第二层代表的对象) 和命题 (第一层代表的对象) 的相互作用. 

相比之下, 类型论是它自己的演绎系统: 它不需要通过任何上层结构来阐述, 比如一阶逻辑. 集合论基于两个基本概念, 集合和命题; 而类型论只有一个基本概念: \emph{类型}. 命题 (即可以被我们进行证明 (prove), 证伪 (disprove), 假设 (assume) 和否定 (negate) 等操作的陈述句\footnote{令人困惑的, ``命题''与``定理''普遍被同义使用(可以追溯到欧几里得). 我们局限于逻辑学家的用法, 根据这种用法, \emph{命题}\emph{可以}证明的陈述, 而\emph{定理}\indexfoot{定理} (或者``引理''\indexfoot{引理}或``推论''\indexfoot{推论})是一个\emph{已经被}证明的陈述句.
因此 ``$0=1$'' 和它的否定``$\neg(0=1)$'' 都是命题, 但是只有后者才是定理.}) 等同于特定的类型, 对应关系参见\pageref{tab:pov}页 \cref{tab:pov}. 因此,  数学上的\emph{证明一个定理} 等同于\emph{构造一个对象} --- 这种情况下, 每个类型的居留元 (inhabitant) 代表一个命题. 

\index{演绎系统}%
这就引出了类型论和集合论之间的另一个区别, 但在解释它之前, 我们必须说一下普通的演绎系统. 非正式的, 演绎系统就是\define{规则}\indexdef{规则}的集合,%
这些集合被称为\define{判断}. \indexdef{判断}%
如果我们认为演绎系统是一个形式化的游戏, \index{游戏!演绎系统看作}%
那么判断是游戏中的``位置'' , 即我们遵循游戏规则可以到达的位置. 我们也可以认为演绎系统是一种代数理论, 这种情况下, 判断就是元素 (就像群的元素), 而演绎规则就是运算 (就像群的乘法). 从逻辑学的角度来看, 判断应该是在元理论``外部的'' 陈述,  而不是理论本身的``内部的''陈述. 

在基于集合论的一阶逻辑的演绎系统的中, 只有一种判断: 给定的命题有证明. 也就是说, 所有的判断只有一种构造, 即``$A$ 有证明''. 比如说这个一阶逻辑规则, ``从 $A$ 和 $B$可以推断出 $A\wedge B$'' 实际上是一个``证明构造'' 的规则, 即给定两个判断``$A$ 有证明''和 ``$B$ 有证明'', 我们可以演绎出``$A\wedge B$ 有证明''. 注意, 判断 ``$A$ 有证明'' 和 \emph{命题} $A$ 本身不是一个等级的, 后者是理论内部的陈述. % In particular, we cannot manipulate it to construct propositions such as ``if $A$ has a proof, then $B$ does not have a proof''---unless we are using our set-theoretic foundation as a meta-theory with which to talk about some other axiomatic system.


类型论中基本的判断, 类似于 ``$A$ 有证明'', 写做``$a:A$''  读作``$a:A$''代表``$a$ 的类型是 $A$'', 或者更不精确地说`` $a$ 是 $A$ 的一个元素''(或者在同伦类型论中, ``$a$ 是 $A$''的一个点). \indexdef{术语}%
\indexdef{元素}%
\indexdef{点!之于类型}%
当类型 $A$ 代表一个命题, 则 $a$ 可以被称为 $A$ 的正确性(provability) 的 \emph{见证(witness)}\index{见证!正确性的}, 或者 $A$ 的真实性(truth) 的\emph{证据(evidence)}\index{证据, 命题真实性的} (甚至是 $A$ 的\emph{证明 (proof)}\index{证明}, 但我们将尽力避免使用这种令人困惑的术语). 这个情况下, 在类型论中, 对于 $a$ 来说判断 $a:A$ 是可推导的, 类似于在一阶逻辑中, 判断 ``$A$ 有证明'' 是可推导的(我们将在整本书中讨论假设,和数学学中的公理).

另一方面, 如果类型 $A$ 被视为一个集合而不是一个类型(尽管如我们所见, 区别会变得模糊),  那么 ``$a:A$' '可以被视为是集合论中的语句 ``$a\in A$''. 然而, 这里有一些必要的区别, ``$a:A$'' 是一个 \emph{判断}而``$a\in A$''是一个\emph{命题}. 特殊的, 在类型论工作过程中, 我们无法编写诸如 ``如果 $a:A$ 错误, 那么 $b:B$ '' 的语句, 也不能 ``证伪'' 判断 `` $a:A$ ''. 

在集合论中, ``成员关系''是讨论两个已经存在的对象`` $a$ ''和`` $A$ ''可能有, 或者没有的关系, 而在类型论中, 我们无法单独讨论孤立的元素``$a$'': 所有元素\emph{就其本质而言}都是某个类型的元素, 而它的类型(一般而言)是唯一确定的. 因此, 当我们非正式的说``令$x$为一个自然数'', 在集合论中这是``令$x$为一个元素, 而且假设 $x\in\nat$'' 的简写, 而在类型论中, ``let $x:\nat$'' 是一个原子语句: 我们不能讨论一个变量, 但是没有指定它的类型.\index{成员关系} 


乍一看来, 这好像是个令人不舒服的限制, 但是这样更接近直觉主义数学上的``令$x$为一个自然数''的含义. 在实践中, 看起来每当我们实际\emph{需要} ``$a\in A$''命题而不是判断时, 可以通过构造一个辅助的集合$B$, 其中$a$是它的元素, 而$A$是一个子集来解决这个问题. 这个情况也很容易在类型论中表现, 通过构造$a$为类型$B$的一个元素, 而让$A$作为 $B$ 的判断式 (predicate);  参见\cref{subsec:prop-subsets}. 

最后一个关于类型论和集合论的区别是对待等同关系. 数学中令人熟悉的等同关系的概念是一个命题: 例如我们能证否一个等同关系或者提出一个等同关系的假设. 而在类型论中, 命题就是类型, 意味着等同关系是一个类型: 对于元素$a,b:A$(代表$a:A$和$b:A$)我们有类型 ``$\id[A]ab$''. (在\emph{同伦}类型论, 等同关系命题的表达方式会有一些不令人熟悉: 参见 \cref{sec:identity-types,cha:basics}, 和本书剩余的部分). 当类型 $\id[A]ab$ 存在居留元时, 我们说 $a$ 和 $b$ 是 \define{(命题)等同}. \index{命题的!等同}%
\index{等同!命题的}%

然而, 在类型论中也需要一个等同\emph{判断}, 它的等级和判断 ``$x:A$''.\index{判断}相同. \symlabel{defn:judgmental-equality}%
它被称为\define{判断等同} \indexdef{等同!判断}%
\indexdef{判断等同}%
或是\define{定义等同}, \indexdef{等同!定义}%
\indexsee{定义等同}{等同, 定义}%
我们可以写做 $a\jdeq b : A$ 或者简写为 $a \jdeq b$. 可以把它理解成``定义上的等同''. 例如, 如果我们通过函数等式 $f(x)=x^2$ 定义函数 $f:\nat\to\nat$, 那么表达式 $f(3)$ 和 $3^2$ 是\emph{定义}等同. 在这个理论中, 否定或者假设定义上的等同是没有意义的; 我们不能说``如果 $x$ 和 $y$ 是定义等同的, 那么 $z$ 和 $w$ 不是定义等同的''. 不管两个表达式是否定义等同, 这都是定义所扩展的问题; 特别的, 这些都是算法\index{算法}可判定的的问题(尽管算法是元理论的, 而不是理论内部的).\index{可判定的!定义等同} 

随着类型论变得更加复杂, 判断等同会变得更加微妙, 但是这是一件好事. 另外, 如果我们认为演绎系统是一个代数理论, 那么判断等同就是这个理论中的等同关系, 类似与群中的元素的等同关系——只是这里有一个令人困惑的地方, 类型论的演绎系统\emph{也}\emph{存在}一个对象(也就是类型``$a=b$''), 也能表示``平等关系''. 

我们也\emph{想要}这样一种判断 ``$a:A$'', 这个判断可以构造其它判断. 例如, 假如我们给定了一个证明 $3^2=9$, 即我们为某些 $p$, 推导了判断 $p:(3^2=9)$. 那么 $p$ 也是 $f(3)=9$ 的证明, 因为\emph{根据定义}, $f(3)$ 就是 $3^2$. 解释这条规则的最好方法就是: 给出判断 $a:A$ 和 $A\jdeq B$, 我们可以推导出判断 $a:B$.

因此对我们来说, 类型论将是基于两种判断的演绎系统:  \begin{center}
\medskip
\begin{tabular}{cl}
\toprule
判断 &含义\\
\midrule
$a : A$ &``$a$ 是一个类型为 $A$  的对象''\\
$a \jdeq b : A$ &``$a$ 是一个类型为 $A$ 的对象''\\
\bottomrule
\end{tabular}
\medskip
\end{center}
%
\symlabel{defn:defeq}%
我们引用定义等同时, 例如, 定义与另一个相同的事物时, 我们使用符号``$\defeq$''. 因此, 上文中定义的函数 $f$ 可以写为 $f(x)\defeq x^2$. 

因为不能将判断合并成更加复杂的语句, 所以符号 ``$:$'' 和符号 ``$\jdeq$'' 的优先级最低. \footnote{在形式\indexfoot{数学!形式}类型论中, 逗号和 $\vdash$ 符号的优先级更加低.%
例如, $x:A,y:B\vdash c:C$ 被解析成 $((x:A),(y:B))\vdash (c:C)$.
不过, 不过, 在这本书中我们避免这种记号直到 \cref{cha:rules}.}
因此, 例如, ``$p:\id{x}{y}$'' 应该被解析成 ``$p:(\id{x}{y})$'', 因为 ``$\id{x}{y}$'' 是一个类型, 而不是``$\id{(p:x)}{y}$'', 因为 ``$p:x$'' 是一个判断, 它不能等同于其它任何东西. 类似的, ``$A\jdeq \id{x}{y}$'' 只能被解析成 ``$A\jdeq(\id{x}{y})$'',  尽管在这种极端情况下, 不管怎样都要加上圆括号便于理解. 此外, 我们会讨论常用的链式等于符号 --- 例如 $a=b=c=d$ 意味着 ``若 $a=b$ 且 $b=c$ 且 $c=d$, 则 $a=d$'' --- 判断等同也是这样. 上下文通常足以让人明白其意图.

这里大概是提及这个常用的数学符号的时机, ``$f:A\to B$'', 表示 $f$ 是一个函数, 传入 $A$ 返回 $B$, 可以看作是一个类型判断, 因为我们用  ``$A\to B$'' 来表示从传入 $A$ 返回 $B$ 的函数类型(这是标准的类型论中的用法; 参见 \cref{sec:pi-types}). 

\index{假设|(defstyle}%
判断的构造可以依赖于 $x:A$ 形式的\emph{假设}, 此处 $x$ 是一个 \indexdef{变量}%
而 $A$ 是一个类型. 例如, 基于假设 $m,n : \nat$, 我们可以构造一个对象 $m + n : \nat$. 另一个例子是, 假设 $A$ 是一个类型, $x,y : A$, 而  $p : \id[A]{x}{y}$, 我们可以构造一个元素 $p^{-1} : \id[A]{y}{x}$. 类似的假设的集合被称为\define{上下文}; \index{上下文}%
从拓扑学的角度来看它可以被称为 ``参数\index{参数!空间} 空间''. 事实上, 上下文必须是关于假设式的有序列表, 因为后面的假设可能依赖前面的假设: 假设 $x:A$ 必须\emph{晚于}任何类型 $A$ 作为变量所出现的假设式. 

如果假设 $x:A$ 中的类型 $A$ 代表一个命题, 那么这个假设是类型论中的\emph{猜想}: \indexdef{猜想}%
我们假设命题 $A$ 成立. 当类型被当作命题, 我们可以忽略它的证明的名称. 因此, 在上面的第二个例子中, 我们可以改为, 假设 $\id[A]{x}{y}$, 我们可以证明 $\id[A]{y}{x}$. 不过, 因为我们做的是 ``证明相关'' 的数学, \index{数学!证明相关}%
我们通常会把证明称为对象. 在上面的例子中, 譬如, 我们可能想要建立 $p^{-1}$ 传递性和自反性的证明, 就像广群一样; 参见 \cref{cha:basics}. 

注意在词语\emph{假设}的含义下, 我们可以假设命题等同(通过假设一个变量$p:x=y$), 但是我们不能假设一个判断等同$x\jdeq y$, 因为它不是一个类型, 它不能存在元素. 不过, 我们可以做一些其它的看起来像是假设命题等同的事情: 如果我们有个一类型或者一个元素, 它是一个变量$x:A$, 那么我们可以用任何特定的元素$a:A$\emph{替换}$x$, 来获得更加特殊的类型或者元素我们会使用一些语言, 像``现在假设 $x\jdeq a$'' t来指代这种替换, 虽然从上面介绍的意义上来说它不是一个\emph{假设}. \index{假设|)}%

出于同样的原因, 我们不能\emph{证明}两个判断之间相等, 因为它不是一个我们可以构造出见证的类型. 不过, 我们有时会把判断等同作为定义的一部分, 例如``存在 $f:A\to B$ 使得 $f(x)\jdeq y$''. 这应该被视为是两个单独的判断: 首先我们关于元素 $f$ 做出判断 $f:A<u2> B$, 然后我们做出额外的判断 $f(x)\jdeq y$. 

在本章剩下的内容中, 我们尝试给出一些类型论的非正式的介绍, 对本书而言, 这已经足够; 更正式的记录在 \cref{cha:rules}. 除了相当明显的规则(比如说判断等同的事物可以互相被替换\index{substitution}), 这些规则可以被归类为为\emph{类型构造器}. 每个类型构造器存在一个方法来构造类型 (可能会使用先前构造出来的类型), 与构造的规则和类型的对象的行为一起. 在绝大部分情况下, 这些规则伴随相当可循的模式, 但是我们在这里不会准确的尝试; 参见 \cref{sec:finite-product-types} 和 \cref{cha:induction}.\index{类型论!非正式的} 


\index{公理!与规则}%
\index{规则!与公理}%
本章介绍的类型论中, 有一个重要的方面, 就是它完全由\emph{规则}, 没有任何\emph{公理}. 在演绎系统中的判断的表达式的描述中, \emph{规则}允许我们根据其它判断的集合, 来断定一个判断, 而\emph{公理}就是我们一开始给出的判断.. 如果我们这样思考, 把演绎系统看成一个游戏, 那么规则就是游戏规则, 而公理就是出生点位. 如果我们认为演绎系统是一个代数理论, 那么规则就是这个理论的操作符, 而公理就是这个理论中特定的\emph{生成器}.

在集合论中, 唯一的规则就是一阶逻辑的规则 (比如说这些规则允许我们根据``$A$ 有证明''和``$B$ 有证明''推断``$A\wedge B$ 有证明''): 所有关于集合的行为的信息都包含在公理中. 相比之下, 在类型论中, 通常这些信息都存在\emph{规则}中, 无需公理.. 比如, 在\cref{sec:finite-product-types}我们会看到一些规则, 允许我们根据 ``$a:A$'' 和 ``$b:B$'', 推断判断 ``$(a,b):A\times B$''  而在集合论中类似的陈述应该是匹配公理 (的结果). 

类型论只使用规则的好处是, 规则是``程序性的''. 特别的, 这使类型理论的良好计算特性为了可能(尽管不是确保), 比如说``正规性''.\index{正规性} 不过, 在传统类型理论使用这种风格, 我们还没有明白如何形式化所有东西, 所以我们需要\emph{同伦} 类型论. 特别的, 在\cref{sec:compute-pi,sec:compute-universe,cha:hits} 中提出的关于类型论的规则, 我们不得不允许它添加额外的公理, 也就是\emph{一阶公理(univalence axiom)}. 但是在本章, 局限于传统的, 只使用规则的类型论.